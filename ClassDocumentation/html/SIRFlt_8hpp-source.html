<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Bayes++ Bayesian Filtering Classes: SIRFlt.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>SIRFlt.hpp</h1><a href="SIRFlt_8hpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#ifndef _BAYES_FILTER_SIR</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define _BAYES_FILTER_SIR</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/*</span>
00005 <span class="comment"> * Bayes++ the Bayesian Filtering Library</span>
00006 <span class="comment"> * Copyright (c) 2002 Michael Stevens</span>
00007 <span class="comment"> * See accompanying Bayes++.htm for terms and conditions of use.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * $Header: /cvsroot/bayesclasses/Bayes++/BayesFilter/SIRFlt.hpp,v 1.14.2.2 2004/07/18 18:38:04 mistevens Exp $</span>
00010 <span class="comment"> * $NoKeywords: $</span>
00011 <span class="comment"> */</span>
00012 
00013 <span class="comment">/*</span>
00014 <span class="comment"> * Sampling Importance Resampleing Filter Scheme.</span>
00015 <span class="comment"> *  Also know as a weighted Booststrap</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * References</span>
00018 <span class="comment"> *  [1] "Novel approach to nonlinear-non-Guassian Bayesian state estimation"</span>
00019 <span class="comment"> *   NJ Gordon, DJ Salmond, AFM Smith IEE Proceeding-F Vol.140 No.2 April 1993</span>
00020 <span class="comment"> *  [2] Building Robust Simulation-based Filter for Evolving Data Sets"</span>
00021 <span class="comment"> *   J Carpenter, P Clifford, P Fearnhead Technical Report Unversity of Oxford</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> *  A variety of reampling algorithms can be used for the SIR filter.</span>
00024 <span class="comment"> *  There are implementations for two algorihtms:</span>
00025 <span class="comment"> *   standard_resample: Standard resample algorithm from [1]</span>
00026 <span class="comment"> *   systematic_resample: A Simple stratified resampler from [2]</span>
00027 <span class="comment"> *  A virtual 'weighted_resample' provides an standard interface to these and defaults</span>
00028 <span class="comment"> *  to the standard_resample.</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> * NOTES:</span>
00031 <span class="comment"> *  SIR algorithm is sensative to random generator</span>
00032 <span class="comment"> *  In particular random uniform must be [0..1) NOT [0..1]</span>
00033 <span class="comment"> *  Quantisation in the random number generator must not approach the sample size.</span>
00034 <span class="comment"> *  This will result in quantisation of the resampling.</span>
00035 <span class="comment"> *  For example if random identically equal to 0 becomes highly probable due to quantisation</span>
00036 <span class="comment"> *  this will result in the first sample being selectively draw whatever its likelihood.</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> *  Numerics</span>
00039 <span class="comment"> *   Resampling requires comparisons of normalised weights. These may</span>
00040 <span class="comment"> *   become insignificant if Likelihoods have a large range. Resampling becomes ill conditioned</span>
00041 <span class="comment"> *   for these samples.</span>
00042 <span class="comment"> */</span>
00043 <span class="preprocessor">#include "<a class="code" href="bayesFlt_8hpp.html">bayesFlt.hpp</a>"</span>
00044 
00045 <span class="comment">/* Filter namespace */</span>
00046 <span class="keyword">namespace </span>Bayesian_filter
00047 {
00048 
<a name="l00049"></a><a class="code" href="structBayesian__filter_1_1SIR__random.html">00049</a> <span class="keyword">struct </span><a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>
00050 <span class="comment">/*</span>
00051 <span class="comment"> * Random number generators interface</span>
00052 <span class="comment"> *  Helper to allow polymorthic use of random number generators</span>
00053 <span class="comment"> */</span>
00054 {
00055     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBayesian__filter_1_1SIR__random.html#a0">normal</a>(<a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a>&amp; v) = 0;
00056     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="structBayesian__filter_1_1SIR__random.html#a1">uniform_01</a>(<a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a>&amp; v) = 0;
00057 };
00058 
00059 
<a name="l00060"></a><a class="code" href="classBayesian__filter_1_1Importance__resampler.html">00060</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Importance__resampler.html">Importance_resampler</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a>
00061 <span class="comment">/*</span>
00062 <span class="comment"> * Importance resampler</span>
00063 <span class="comment"> *  Represents a function that computes the posterior resampling from importance weights</span>
00064 <span class="comment"> *  Polymorphic function object used to parameterise the resampling operation</span>
00065 <span class="comment"> */</span>
00066 {
00067 <span class="keyword">public</span>:
<a name="l00068"></a><a class="code" href="classBayesian__filter_1_1Importance__resampler.html#w0">00068</a>     <span class="keyword">typedef</span> std::vector&lt;std::size_t&gt; <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#w0">Resamples_t</a>;   <span class="comment">// resampling counts</span>
00069 
00070     <span class="keyword">virtual</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#a0">resample</a> (<a class="code" href="classBayesian__filter_1_1Importance__resampler.html#w0">Resamples_t</a>&amp; presamples, std::size_t&amp; uresamples, <a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a>&amp; w, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; r) <span class="keyword">const</span> = 0;
00071     <span class="comment">/*</span>
00072 <span class="comment">     * The resampling function</span>
00073 <span class="comment">     *  Weights w are proportional to the posterior Likelihood of a state</span>
00074 <span class="comment">     * Sideeffect</span>
00075 <span class="comment">     *  w becomes a normalised cumulative sum</span>
00076 <span class="comment">     *  Random draws can be made from 'r'</span>
00077 <span class="comment">     *</span>
00078 <span class="comment">     * Exceptions:</span>
00079 <span class="comment">     *  bayes_filter_exception for numerical problems with weights including</span>
00080 <span class="comment">     *   any w &lt; 0, all w == 0</span>
00081 <span class="comment">     * Return</span>
00082 <span class="comment">     *  lcond, smallest normalised weight, represents conditioning of resampling solution</span>
00083 <span class="comment">     *  presamples: posterior resample, the number of times each sample should appear posterior baes on it weight</span>
00084 <span class="comment">     *  uresample: the number of unique resamples in the posterior == number of non zero elements in presamples</span>
00085 <span class="comment">     * Preconditions</span>
00086 <span class="comment">     *  wresample,w must have same size</span>
00087 <span class="comment">     */</span>
00088 };
00089 
<a name="l00090"></a><a class="code" href="classBayesian__filter_1_1Standard__resampler.html">00090</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Standard__resampler.html">Standard_resampler</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html">Importance_resampler</a>
00091 <span class="comment">// Standard resample algorithm from [1]</span>
00092 {
00093     <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#a0">resample</a> (Resamples_t&amp; presamples, std::size_t&amp; uresamples, <a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a>&amp; w, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; r) <span class="keyword">const</span>;
00094 };
00095 
<a name="l00096"></a><a class="code" href="classBayesian__filter_1_1Systematic__resampler.html">00096</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Systematic__resampler.html">Systematic_resampler</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html">Importance_resampler</a>
00097 <span class="comment">// Systematic resample algorithm from [2]</span>
00098 {
00099     <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#a0">resample</a> (Resamples_t&amp; presamples, std::size_t&amp; uresamples, <a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a>&amp; w, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; r) <span class="keyword">const</span>;
00100 };
00101 
00102 
00103 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Predict_model&gt;
<a name="l00104"></a><a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">00104</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_general_predict_model</a>: <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Predict__model.html">Predict_model</a>, <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">Sampled_predict_model</a>
00105 <span class="comment">/*</span>
00106 <span class="comment"> * Generalise a predict model to sampled predict model using and SIR random</span>
00107 <span class="comment"> *  To instantiate template std::sqrt is required</span>
00108 <span class="comment"> */</span>
00109 {
00110 <span class="keyword">public</span>:
<a name="l00111"></a><a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a0">00111</a>     <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a0">Sampled_general_predict_model</a> (std::size_t x_size, std::size_t q_size, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; random_helper) :
00112         <a class="code" href="classBayesian__filter_1_1Predict__model.html">Predict_model</a>(x_size, q_size),
00113         <a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">Sampled_predict_model</a>(),
00114         genn(random_helper),
00115         xp(x_size),
00116         n(q_size), rootq(q_size)
00117     {
00118         first_init = <span class="keyword">true</span>;
00119     }
00120 
<a name="l00121"></a><a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a1">00121</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a1">fw</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span>
00122     <span class="comment">/*</span>
00123 <span class="comment">     * Definition of sampler for addative noise model given state x</span>
00124 <span class="comment">     *  Generate Gaussian correlated samples</span>
00125 <span class="comment">     * Precond: init_GqG, automatic on first use</span>
00126 <span class="comment">     */</span>
00127     {
00128         <span class="keywordflow">if</span> (first_init)
00129             <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a2">init_GqG</a>();
00130                             <span class="comment">// Predict state using supplied functional predict model</span>
00131         xp = Predict_model::f(x);
00132                             <span class="comment">// Additive random noise</span>
00133         genn.<a class="code" href="structBayesian__filter_1_1SIR__random.html#a0">normal</a>(n);             <span class="comment">// independant zero mean normal</span>
00134                                     <span class="comment">// multiply elements by std dev</span>
00135         <span class="keywordflow">for</span> (FM::DenseVec::iterator ni = n.begin(); ni != n.end(); ++ni) {
00136             *ni *= rootq[ni.index()];
00137         }
00138         <a class="code" href="namespaceBayesian__filter__matrix.html#a50">FM::noalias</a>(xp) += FM::prod(this-&gt;G,n);         <span class="comment">// add correlated noise</span>
00139         <span class="keywordflow">return</span> xp;
00140     }
00141 
<a name="l00142"></a><a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a2">00142</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html#a2">init_GqG</a>() const
00143     <span class="comment">/* initialise predict given a change to q,G</span>
00144 <span class="comment">     *  Implementation: Update rootq</span>
00145 <span class="comment">     */</span>
00146     {
00147         first_init = <span class="keyword">false</span>;
00148         <span class="keywordflow">for</span> (FM::Vec::const_iterator qi = this-&gt;q.begin(); qi != this-&gt;q.end(); ++qi) {
00149             <span class="keywordflow">if</span> (*qi &lt; 0.)
00150                 <a class="code" href="classBayesian__filter_1_1Bayes__base.html#e0">error</a> (<a class="code" href="classBayesian__filter_1_1Numeric__exception.html">Numeric_exception</a>(<span class="stringliteral">"Negative q in init_GqG"</span>));
00151             rootq[qi.index()] = std::sqrt(*qi);
00152         }
00153     }
00154 <span class="keyword">private</span>:
00155     <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; genn;
00156     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> xp;
00157     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a> n;
00158     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> rootq;      <span class="comment">// Optimisation of sqrt(q) calculation, automatic on first use</span>
00159     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> first_init;    
00160 };
00161 
<a name="l00162"></a><a class="code" href="namespaceBayesian__filter.html#a1">00162</a> <span class="keyword">typedef</span> <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_general_predict_model&lt;Linear_predict_model&gt;</a> <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_LiAd_predict_model</a>;
<a name="l00163"></a><a class="code" href="namespaceBayesian__filter.html#a2">00163</a> <span class="keyword">typedef</span> <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_general_predict_model&lt;Linear_invertable_predict_model&gt;</a> <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_LiInAd_predict_model</a>;
00164 <span class="comment">// Sampled predict model generalisations</span>
00165 <span class="comment">//  Names a shortened to first two letters of their model properties</span>
00166 
00167 
00168 
<a name="l00169"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html">00169</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1SIR__scheme.html">SIR_scheme</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Sample__filter.html">Sample_filter</a>
00170 <span class="comment">/*</span>
00171 <span class="comment"> * Sampling Importance Resampleing Filter Scheme.</span>
00172 <span class="comment"> *  Implement a general form of SIR filter</span>
00173 <span class="comment"> *  Importance resampling is delayed until an update is required. The sampler used</span>
00174 <span class="comment"> *  is a parameter of update to allow a wide variety of usage.</span>
00175 <span class="comment"> *  A stochastic sample is defined as a sample with a unqiue stochastic history other then roughening</span>
00176 <span class="comment"> */</span>
00177 {
00178     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html">SIR_kalman_scheme</a>;
00179 <span class="keyword">public</span>:
<a name="l00180"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o0">00180</a>     std::size_t <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o0">stochastic_samples</a>; <span class="comment">// Number of stochastic samples in S</span>
00181 
00182     <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a0">SIR_scheme</a> (std::size_t x_size, std::size_t s_size, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; random_helper);
00183     <a class="code" href="classBayesian__filter_1_1SIR__scheme.html">SIR_scheme</a>&amp; <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a1">operator= </a>(<span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html">SIR_scheme</a>&amp;);
00184     <span class="comment">// Optimise copy assignment to only copy filter state</span>
00185 
00186     <span class="comment">/* Specialisations for filter algorithm */</span>
00187     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a2">init_S</a> ();
00188 
<a name="l00189"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a3">00189</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a3">update_resample</a> ()
00190     <span class="comment">// Default resampling update</span>
00191     {   <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a3">update_resample</a> (<a class="code" href="classBayesian__filter_1_1Standard__resampler.html">Standard_resampler</a>());
00192     }
00193 
00194     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a3">update_resample</a> (<span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html">Importance_resampler</a>&amp; resampler);
00195     <span class="comment">/* Update: resample particles using weights and then roughen</span>
00196 <span class="comment">     *  Return: lcond</span>
00197 <span class="comment">     */</span>
00198 
<a name="l00199"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a5">00199</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a5">predict</a> (<a class="code" href="classBayesian__filter_1_1Functional__predict__model.html">Functional_predict_model</a>&amp; f)
00200     <span class="comment">// Predict samples without noise</span>
00201     {   Sample_filter::predict (f);
00202     }
00203     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a5">predict</a> (<a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">Sampled_predict_model</a>&amp; f);
00204     <span class="comment">// Predict samples with noise model</span>
00205 
00206     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a7">observe</a> (<a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html">Likelihood_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z);
00207     <span class="comment">// Weight particles using likelihood model h and z</span>
00208 
00209     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a8">observe_likelihood</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; lw);
00210     <span class="comment">// Observation fusion directly from likelihood weights</span>
00211 
<a name="l00212"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o1">00212</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o1">rougheningK</a>;          <span class="comment">// Current roughening value (0 implies no roughening)</span>
<a name="l00213"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a9">00213</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#a9">roughen</a>()
00214     <span class="comment">// Generalised roughening:  Default to roughen_minmax</span>
00215     {
00216         <span class="keywordflow">if</span> (<a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o1">rougheningK</a> != 0.)
00217             <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#b0">roughen_minmax</a> (S, <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o1">rougheningK</a>);
00218     }
00219 
00220     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#e0">copy_resamples</a> (<a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a>&amp; P, <span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#w0">Importance_resampler::Resamples_t</a>&amp; presamples);
00221     <span class="comment">// Update P by selectively copying based on presamples </span>
00222 
<a name="l00223"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o2">00223</a>     <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#o2">random</a>;         <span class="comment">// Reference random number generator helper</span>
00224 
00225 <span class="keyword">protected</span>:
00226     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#b0">roughen_minmax</a> (<a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a>&amp; P, <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> K) <span class="keyword">const</span>;  <span class="comment">// roughening using minmax of P distribution</span>
<a name="l00227"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p0">00227</a>     <a class="code" href="classBayesian__filter_1_1Importance__resampler.html#w0">Importance_resampler::Resamples_t</a> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p0">resamples</a>;        <span class="comment">// resampling counts</span>
<a name="l00228"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p1">00228</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a9">FM::DenseVec</a> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p1">wir</a>;           <span class="comment">// resamping weights</span>
<a name="l00229"></a><a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p2">00229</a>     <span class="keywordtype">bool</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html#p2">wir_update</a>;            <span class="comment">// weights have been updated requring a resampling on update</span>
00230 <span class="keyword">private</span>:
00231     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> rougheningKinit;
00232     std::size_t x_size;
00233 };
00234 
00235 
<a name="l00236"></a><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html">00236</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html">SIR_kalman_scheme</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1SIR__scheme.html">SIR_scheme</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">Kalman_state_filter</a>
00237 <span class="comment">/*</span>
00238 <span class="comment"> * SIR implementation of a Kalman filter</span>
00239 <span class="comment"> *  Updates Kalman statistics of SIR_filter</span>
00240 <span class="comment"> *  These statistics are use to provide a specialised correlated roughening procedure</span>
00241 <span class="comment"> */</span>
00242 {
00243 <span class="keyword">public</span>:
00244     <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a0">SIR_kalman_scheme</a> (std::size_t x_size, std::size_t s_size, <a class="code" href="structBayesian__filter_1_1SIR__random.html">SIR_random</a>&amp; random_helper);
00245 
00246     <span class="comment">/* Specialisations for filter algorithm */</span>
00247 
00248     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a1">init</a> ();
00249 
<a name="l00250"></a><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a2">00250</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a2">update</a> ()
00251     <span class="comment">// Implement Kalman_filter::update identically to SIR_scheme</span>
00252     {   (<span class="keywordtype">void</span>)SIR_scheme::update_resample();
00253     }
00254 
<a name="l00255"></a><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a3">00255</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a3">update_resample</a> ()
00256     <span class="comment">// Implement identically to SIR_scheme</span>
00257     {   <span class="keywordflow">return</span> SIR_scheme::update_resample();
00258     }
00259 
00260     Float <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a3">update_resample</a> (<span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1Importance__resampler.html">Importance_resampler</a>&amp; resampler);
00261     <span class="comment">// Modified SIR_filter update implementation: update mean and covariance of sampled distribution</span>
00262 
00263     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a5">update_statistics</a> ();
00264     <span class="comment">// Update kalman statistics without resampling</span>
00265 
<a name="l00266"></a><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a6">00266</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#a6">roughen</a>()
00267     {   <span class="comment">// Specialised correlated roughening</span>
00268         <span class="keywordflow">if</span> (rougheningK != 0.)
00269             <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#b0">roughen_correlated</a> (S, rougheningK);
00270     }
00271 
00272 <span class="keyword">protected</span>:
00273     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#b0">roughen_correlated</a> (<a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a>&amp; P, Float K);    <span class="comment">// Roughening using covariance of P distribution</span>
<a name="l00274"></a><a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#p0">00274</a>     <a class="code" href="classBayesian__filter_1_1Sampled__general__predict__model.html">Sampled_LiAd_predict_model</a> <a class="code" href="classBayesian__filter_1_1SIR__kalman__scheme.html#p0">roughen_model</a>;       <span class="comment">// roughening predict</span>
00275 <span class="keyword">private</span>:
00276     <span class="keyword">static</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> scaled_vector_square(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; v, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a>&amp; S);
00277     <span class="keywordtype">void</span> mean();
00278 };
00279 
00280 
00281 }<span class="comment">//namespace</span>
00282 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 19:23:17 2005 for Bayes++ Bayesian Filtering Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
