<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Bayes++ Bayesian Filtering Classes: uBLASmatrix.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>uBLASmatrix.hpp</h1><a href="uBLASmatrix_8hpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*</span>
00002 <span class="comment"> * Bayes++ the Bayesian Filtering Library</span>
00003 <span class="comment"> * Copyright (c) 2002 Michael Stevens</span>
00004 <span class="comment"> * See accompanying Bayes++.htm for terms and conditions of use.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * $Header: /cvsroot/bayesclasses/Bayes++/BayesFilter/uBLASmatrix.hpp,v 1.24.2.6 2005/01/15 11:24:32 mistevens Exp $</span>
00007 <span class="comment"> * $NoKeywords: $</span>
00008 <span class="comment"> */</span>
00009 
00010 <span class="comment">/*</span>
00011 <span class="comment"> * Common type independant uBlas interface</span>
00012 <span class="comment"> *  Should be include after base types have been defined</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * Everything in namespace Bayes_filter_matrix is intended to support the matrix storage</span>
00015 <span class="comment"> * and algebra requirements of the library. Therefore the interfaces and implementation is</span>
00016 <span class="comment"> * not intended to be stable. Nor is this a general purpose adapator for uBLAS</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * Note on row_major matrices</span>
00019 <span class="comment"> *  The implementation uses row major extensively. The computation of symetric products P*P' is </span>
00020 <span class="comment"> *  most efficient with row operations. These products are used extensively so the default</span>
00021 <span class="comment"> *  is to use row_major matrices</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="comment">/* Filter Matrix Namespace */</span>
00025 <span class="keyword">namespace </span>Bayesian_filter_matrix
00026 {
00027                         <span class="comment">// Allow use a few functions in own namespace (particular useful for compilers with Konig lookup)</span>
00028 <span class="keyword">using</span> ublas::row;
00029 <span class="keyword">using</span> ublas::column;
00030 <span class="keyword">using</span> ublas::trans;
00031 <span class="keyword">using</span> ublas::prod;      <span class="comment">// These do not apply to the templated prod&lt;temp&gt; funtions</span>
00032 <span class="keyword">using</span> ublas::inner_prod;
00033 <span class="keyword">using</span> ublas::outer_prod;
00034 
<a name="l00035"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a70">00035</a> <span class="keyword">enum</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a70">EmptyTag</a> {<a class="code" href="namespaceBayesian__filter__matrix.html#a70a17">Empty</a>};  <span class="comment">// Tag type used for empty matrix constructor</span>
00036 
00037 <span class="preprocessor">#if (BOOST_VERSION &gt;= 103100)</span>
00038 <span class="preprocessor"></span><span class="keyword">using</span> ublas::noalias;
00039 <span class="preprocessor">#else</span>
00040 <span class="preprocessor"></span><span class="keyword">namespace </span>detail
00041 {
00042     <span class="comment">// Assignment proxy.</span>
00043     <span class="comment">// Provides temporary free assigment when LHS has no alias on RHS</span>
00044     <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;
<a name="l00045"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">00045</a>     <span class="keyword">class </span><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">noalias_proxy</a> {
00046     <span class="keyword">public</span>:
00047         BOOST_UBLAS_INLINE
<a name="l00048"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a0">00048</a>         <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a0">noalias_proxy</a> (C&amp; lval):
00049             lval_ (lval) {}
00050 
00051         <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
00052         BOOST_UBLAS_INLINE
<a name="l00053"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a1">00053</a>         <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a1">operator= </a>(<span class="keyword">const</span> E&amp; e) {
00054             lval_.assign (e);
00055         }
00056 
00057         <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
00058         BOOST_UBLAS_INLINE
<a name="l00059"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a2">00059</a>         <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a2">operator+= </a>(<span class="keyword">const</span> E&amp; e) {
00060             lval_.plus_assign (e);
00061         }
00062 
00063         <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
00064         BOOST_UBLAS_INLINE
<a name="l00065"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a3">00065</a>         <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a3">operator-= </a>(<span class="keyword">const</span> E&amp; e) {
00066             lval_.minus_assign (e);
00067         }
00068 
00069     <span class="keyword">private</span>:  <span class="comment">// nonassignable</span>
00070         <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html#a1">operator=</a>( <span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">noalias_proxy</a>&amp; );
00071     <span class="keyword">private</span>:
00072         C&amp; lval_;
00073     };
00074 
00075 }<span class="comment">//namespace detail</span>
00076 
00077 <span class="comment">// Improve syntax of effcient assignment where no aliases of LHS appear on the RHS</span>
00078 <span class="comment">//  noalias(lhs) = rhs_expression</span>
00079 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
00080 BOOST_UBLAS_INLINE
<a name="l00081"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a49">00081</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">detail::noalias_proxy&lt;E&gt;</a> <a class="code" href="namespaceBayesian__filter__matrix.html#a49">noalias</a> (ublas::matrix_expression&lt;E&gt;&amp; lvalue) {
00082     <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">detail::noalias_proxy&lt;E&gt;</a> (lvalue() );
00083 }
00084 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
00085 BOOST_UBLAS_INLINE
<a name="l00086"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a50">00086</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">detail::noalias_proxy&lt;E&gt;</a> <a class="code" href="namespaceBayesian__filter__matrix.html#a49">noalias</a> (ublas::vector_expression&lt;E&gt;&amp; lvalue) {
00087     <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1noalias__proxy.html">detail::noalias_proxy&lt;E&gt;</a> (lvalue() );
00088 }
00089 
00090 <span class="preprocessor">#endif</span>
00091 <span class="preprocessor"></span>
00092 
00093 <span class="keyword">namespace </span>detail        <span class="comment">// Lots of implementation detail</span>
00094 {
00095 
00096 <span class="comment">/*</span>
00097 <span class="comment"> * Filter Vec type</span>
00098 <span class="comment"> */</span>
00099 <span class="keyword">template</span> &lt;<span class="keyword">class</span> VecBase&gt;
<a name="l00100"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">00100</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">FMVec</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>
00101 {
00102 <span class="keyword">public</span>:
00103     <span class="comment">// No Default Constructor. Empty creation is very error prone</span>
<a name="l00104"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">00104</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">FMVec</a>(EmptyTag) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>()
00105     {}  <span class="comment">// Empty constructor</span>
<a name="l00106"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a1">00106</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">FMVec</a>(std::size_t size) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>(size)
00107     {}  <span class="comment">// Normal sized constructor</span>
<a name="l00108"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a2">00108</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">FMVec</a>(<span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">FMVec</a>&amp; c) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>(static_cast&lt;const <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>&amp;&gt;(c))
00109     {}  <span class="comment">// Copy constructor</span>
00110     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00111"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a3">00111</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">FMVec</a>(<span class="keyword">const</span> ublas::vector_expression&lt;E&gt;&amp; e) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>(e)
00112     {}  <span class="comment">// vector_expression copy constructor</span>
00113     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00114"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a4">00114</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a0">FMVec</a>(<span class="keyword">const</span> ublas::matrix_column&lt;E&gt;&amp; e) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1VecBase.html">VecBase</a>(e)
00115     {}  <span class="comment">// conversion copy constructor, hides the implict copy required for matrix column access</span>
00116 
00117     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00118"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a5">00118</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">FMVec</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a5">operator= </a>(<span class="keyword">const</span> ublas::vector_expression&lt;E&gt;&amp; r)
00119     {   <span class="comment">// Expression assignment; may be dependant on r</span>
00120         VecBase::operator=(r);
00121         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00122     }
<a name="l00123"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a6">00123</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">FMVec</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a5">operator= </a>(<span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html">FMVec</a>&amp; r)
00124     {   <span class="comment">// Vector assignment; independant</span>
00125         assign(r);
00126         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00127     }
00128 
00129     <span class="comment">// Sub-range selection operators</span>
<a name="l00130"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a7">00130</a>     <span class="keyword">const</span> ublas::vector_range&lt;const VecBase&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a7">sub_range</a>(std::size_t b, std::size_t e)<span class="keyword"> const</span>
00131 <span class="keyword">    </span>{
00132         <span class="keywordflow">return</span> ublas::vector_range&lt;const VecBase&gt;(*<span class="keyword">this</span>, ublas::range(b,e));
00133     }
<a name="l00134"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a8">00134</a>     ublas::vector_range&lt;VecBase&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMVec.html#a7">sub_range</a>(std::size_t b, std::size_t e)
00135     {
00136         <span class="keywordflow">return</span> ublas::vector_range&lt;VecBase&gt;(*<span class="keyword">this</span>, ublas::range(b,e));
00137     }
00138 };
00139 
00140 
00141 <span class="comment">/*</span>
00142 <span class="comment"> * Filter Matrix class template. Augmentation for uBlas MatrixBase</span>
00143 <span class="comment"> */</span>
00144 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixBase&gt;
<a name="l00145"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">00145</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix</a> : <span class="keyword">public</span> <a class="code" href="classMatrixBase.html">MatrixBase</a>
00146 {
00147 <span class="keyword">public</span>:
<a name="l00148"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w0">00148</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> MatrixBase::value_type <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w0">value_type</a>;
00149 
00150     <span class="comment">// No Default Constructor. Empty creation is very error prone</span>
<a name="l00151"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a0">00151</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a0">FMMatrix</a>(EmptyTag) : <a class="code" href="classMatrixBase.html">MatrixBase</a>()
00152     {}  <span class="comment">// Empty constructor</span>
<a name="l00153"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a1">00153</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a0">FMMatrix</a>(std::size_t size1, std::size_t size2) : <a class="code" href="classMatrixBase.html">MatrixBase</a>(size1,size2)
00154     {}  <span class="comment">// Normal sized constructor</span>
<a name="l00155"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a2">00155</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a0">FMMatrix</a>(<span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix</a>&amp; c) : <a class="code" href="classMatrixBase.html">MatrixBase</a>(static_cast&lt;const <a class="code" href="classMatrixBase.html">MatrixBase</a>&amp;&gt;(c))
00156     {}  <span class="comment">// Copy constructor</span>
00157     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00158"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a3">00158</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a0">FMMatrix</a>(<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; e) : <a class="code" href="classMatrixBase.html">MatrixBase</a>(e)
00159     {}  <span class="comment">// matrix_expression copy constructor</span>
00160 
00161     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00162"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a4">00162</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a4">operator= </a>(<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; r)
00163     {   <span class="comment">// Expression assignment; may be dependant on r</span>
00164         MatrixBase::operator=(r);
00165         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00166     }
<a name="l00167"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a5">00167</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a4">operator= </a>(<span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix</a>&amp; r)
00168     {   <span class="comment">// Matrix assignment; independant</span>
00169         assign (r);
00170         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00171     }
00172 
00173     <span class="comment">// Row,Column vector proxies</span>
<a name="l00174"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w1">00174</a>     <span class="keyword">typedef</span> ublas::matrix_row&lt;FMMatrix&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w1">Row</a>;
<a name="l00175"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w2">00175</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> ublas::matrix_row&lt;const FMMatrix&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w2">const_Row</a>;
<a name="l00176"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w3">00176</a>     <span class="keyword">typedef</span> ublas::matrix_column&lt;FMMatrix&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w3">Column</a>;
<a name="l00177"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w4">00177</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> ublas::matrix_column&lt;const FMMatrix&gt; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w4">const_Column</a>;
00178 
00179     <span class="comment">// Vector proxies from iterators - static members dependant on MatrixBase type</span>
00180     <span class="comment">// ri() returns container associated with iterator. static_cast required as typeof(ri()) may not be typeof(MM)</span>
<a name="l00181"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e0">00181</a>     <span class="keyword">static</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w1">Row</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e0">rowi</a>(<span class="keyword">const</span> <span class="keyword">typename</span> MatrixBase::iterator1&amp; ri)
00182     {
00183         <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w1">Row</a>(static_cast&lt;FMMatrix&amp;&gt;(ri()), ri.index1());
00184     }
<a name="l00185"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e1">00185</a>     <span class="keyword">static</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w2">const_Row</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e0">rowi</a>(<span class="keyword">const</span> <span class="keyword">typename</span> MatrixBase::const_iterator1&amp; ri)
00186     {
00187         <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w2">const_Row</a>(static_cast&lt;const FMMatrix&amp;&gt;(ri()), ri.index1());
00188     }
<a name="l00189"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e2">00189</a>     <span class="keyword">static</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w3">Column</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e2">columni</a>(<span class="keyword">const</span> <span class="keyword">typename</span> MatrixBase::iterator2&amp; ci)
00190     {
00191         <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w3">Column</a>(static_cast&lt;FMMatrix&amp;&gt;(ci()), ci.index2());
00192     }
<a name="l00193"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e3">00193</a>     <span class="keyword">static</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w4">const_Column</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#e2">columni</a>(<span class="keyword">const</span> <span class="keyword">typename</span> MatrixBase::const_iterator2&amp; ci)
00194     {
00195         <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#w4">const_Column</a>(static_cast&lt;const FMMatrix&amp;&gt;(ci()), ci.index2());
00196     }
00197 
00198     <span class="comment">// Sub-range selection operators</span>
00199     ublas::matrix_range&lt;const MatrixBase&gt;
<a name="l00200"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a6">00200</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a6">sub_matrix</a>(std::size_t s1, std::size_t e1, std::size_t s2, std::size_t e2)<span class="keyword"> const</span>
00201 <span class="keyword">    </span>{
00202         <span class="keywordflow">return</span> ublas::matrix_range&lt;const MatrixBase&gt; (*<span class="keyword">this</span>, ublas::range(s1,e1), ublas::range(s2,e2));
00203     }
00204     ublas::matrix_range&lt;MatrixBase&gt;
<a name="l00205"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a7">00205</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a6">sub_matrix</a>(std::size_t s1, std::size_t e1, std::size_t s2, std::size_t e2)
00206     {
00207         <span class="keywordflow">return</span> ublas::matrix_range&lt;MatrixBase&gt; (*<span class="keyword">this</span>, ublas::range(s1,e1), ublas::range(s2,e2));
00208     }
00209 
00210     <span class="comment">// Requires boost_1.30.0 which has a generalised matrix_vector_slice</span>
00211     ublas::matrix_vector_slice&lt;const MatrixBase&gt;
<a name="l00212"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a8">00212</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a8">sub_column</a>(std::size_t s1, std::size_t e1, std::size_t s2) <span class="keyword">const</span> 
00213     <span class="comment">// Column vector s2 with rows [s1,e1)</span>
00214     {
00215         <span class="keywordflow">return</span> ublas::matrix_vector_slice&lt;const MatrixBase&gt; (*<span class="keyword">this</span>, ublas::slice(s1,1,e1-s1), ublas::slice(s2,0,e1-s1));
00216     }
00217     ublas::matrix_vector_slice&lt;MatrixBase&gt;
<a name="l00218"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a9">00218</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html#a8">sub_column</a>(std::size_t s1, std::size_t e1, std::size_t s2)
00219     <span class="comment">// Column vector s2 with rows [s1,e1)</span>
00220     {
00221         <span class="keywordflow">return</span> ublas::matrix_vector_slice&lt;MatrixBase&gt; (*<span class="keyword">this</span>, ublas::slice(s1,1,e1-s1), ublas::slice(s2,0,e1-s1));
00222     }
00223 };
00224 
00225 
00226 <span class="comment">/*</span>
00227 <span class="comment"> * Helper template to allow member construction before base class</span>
00228 <span class="comment"> *  Boost version does not work as it passes by value</span>
00229 <span class="comment"> */</span>
00230 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MemberType&gt;
<a name="l00231"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">00231</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">BaseFromMember</a>
00232 {
00233 <span class="keyword">protected</span>:
<a name="l00234"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#p0">00234</a>     MemberType member;
<a name="l00235"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b0">00235</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b0">BaseFromMember</a>() : member()
00236     {}
00237 
00238     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;
<a name="l00239"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b1">00239</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b0">BaseFromMember</a>( <span class="keyword">const</span> T1&amp; x1 ) : member( x1 )
00240     {}
00241 
00242     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00243"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b2">00243</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html#b0">BaseFromMember</a>( <span class="keyword">const</span> T1&amp; x1, <span class="keyword">const</span> T2&amp; x2 ) : member( x1, x2 )
00244     {}
00245 };
00246 
00247 
00248 <span class="comment">/*</span>
00249 <span class="comment"> * We require static type conversion between Symmetric matrices and equivilent row major matrices</span>
00250 <span class="comment"> * Therefore we create symmetric matrix types, using a MatrixBase for storage</span>
00251 <span class="comment"> * and wraps this in a symmetric_adaptor</span>
00252 <span class="comment"> */</span>
00253 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixBase&gt;
<a name="l00254"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html">00254</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html">SymMatrixWrapper</a> :
00255     <span class="keyword">private</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">BaseFromMember</a>&lt;MatrixBase&gt;,  <span class="comment">// allow construction of MatrixBase member before symmetric_adaptor</span>
00256     <span class="keyword">public</span> ublas::symmetric_adaptor&lt;MatrixBase, ublas::upper&gt;
00257 {
00258     <span class="keyword">typedef</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">BaseFromMember&lt;MatrixBase&gt;</a> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>;
00259     <span class="keyword">typedef</span> ublas::symmetric_adaptor&lt;MatrixBase, ublas::upper&gt; symadaptor_type;
00260 <span class="keyword">public</span>:
<a name="l00261"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a0">00261</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a0">SymMatrixWrapper</a> () : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>(), symadaptor_type(<a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>::member)
00262     {}
<a name="l00263"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a1">00263</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a0">SymMatrixWrapper</a> (std::size_t size1, std::size_t size2) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>(size1,size2), symadaptor_type(<a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>::member)
00264     {}  <span class="comment">// Normal sized constructor</span>
<a name="l00265"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a2">00265</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a0">SymMatrixWrapper</a> (<span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html">SymMatrixWrapper</a>&amp; r) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>(reinterpret_cast&lt;const <a class="code" href="classMatrixBase.html">MatrixBase</a>&amp;&gt;(r)), symadaptor_type(<a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>::member)
00266     {}  <span class="comment">// Explict copy construction referencing the copy reinterpreted as a MatrixBase</span>
00267     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00268"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a3">00268</a>     <span class="keyword">explicit</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a0">SymMatrixWrapper</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; e) : <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>(e), symadaptor_type(<a class="code" href="classBayesian__filter__matrix_1_1detail_1_1BaseFromMember.html">matrix_type</a>::member)
00269     {}  <span class="comment">// Explict matrix_expression conversion constructor</span>
00270 
00271     <span class="keyword">template</span> &lt;<span class="keyword">class</span> E&gt;
<a name="l00272"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a4">00272</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html">SymMatrixWrapper</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a4">operator=</a>(<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; r)
00273     {
00274         symadaptor_type::operator=(r);
00275         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00276     }
00277 
00278     <span class="comment">// Conversions straight to a FMMatrix, equivilent to a RowMatrix types</span>
<a name="l00279"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a5">00279</a>     <span class="keyword">const</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix&lt;MatrixBase&gt;</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a5">asRowMatrix</a>()<span class="keyword"> const</span>
00280 <span class="keyword">    </span>{
00281         <span class="keywordflow">return</span> static_cast&lt;const FMMatrix&lt;MatrixBase&gt;&amp; &gt;(matrix_type::member);
00282     }
<a name="l00283"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a6">00283</a>     <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1FMMatrix.html">FMMatrix&lt;MatrixBase&gt;</a>&amp; <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a5">asRowMatrix</a>()
00284     {
00285         <span class="keywordflow">return</span> static_cast&lt;FMMatrix&lt;MatrixBase&gt;&amp; &gt;(matrix_type::member);
00286     }
00287 
00288     <span class="comment">// Matrix storage members</span>
<a name="l00289"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a7">00289</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a7">clear</a>()
00290     {   matrix_type::member.clear();
00291     }
<a name="l00292"></a><a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a8">00292</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter__matrix_1_1detail_1_1SymMatrixWrapper.html#a8">resize</a>(std::size_t nsize1, std::size_t nsize2, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
00293     {
00294         matrix_type::member.resize(nsize1, nsize2, preserve);
00295     }
00296 };
00297 
00298 }<span class="comment">//namespace detail</span>
00299 
00300 
00301 
00302 
00303 <span class="comment">/*</span>
00304 <span class="comment"> * Vector / Matrix types</span>
00305 <span class="comment"> *  Finally the definitions !</span>
00306 <span class="comment"> */</span>
00307 <span class="keyword">using</span> detail::FMVec;        <span class="comment">// Template class for template parameter matching</span>
00308 <span class="keyword">using</span> detail::FMMatrix;
00309 
00310                             <span class="comment">// Default types</span>
<a name="l00311"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a1">00311</a> <span class="keyword">typedef</span> FMVec&lt;detail::BaseVector&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>;
<a name="l00312"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a2">00312</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseRowMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a2">RowMatrix</a>;
<a name="l00313"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a3">00313</a> <span class="keyword">typedef</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a2">RowMatrix</a> <a class="code" href="namespaceBayesian__filter__matrix.html#a3">Matrix</a>;
<a name="l00314"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a4">00314</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseColMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a4">ColMatrix</a>;
<a name="l00315"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a5">00315</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::SymMatrixWrapper&lt;detail::BaseRowMatrix&gt; &gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a5">SymMatrix</a>;
<a name="l00316"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a6">00316</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseUpperTriMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a6">UTriMatrix</a>;
<a name="l00317"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a7">00317</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseLowerTriMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a7">LTriMatrix</a>;
<a name="l00318"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a8">00318</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDiagMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a8">DiagMatrix</a>;
00319 
00320                             <span class="comment">// Explicitly dense types</span>
<a name="l00321"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a9">00321</a> <span class="keyword">typedef</span> FMVec&lt;detail::BaseDenseVector&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a9">DenseVec</a>;
<a name="l00322"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a10">00322</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseRowMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a10">DenseRowMatrix</a>;
<a name="l00323"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a11">00323</a> <span class="keyword">typedef</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a10">DenseRowMatrix</a> <a class="code" href="namespaceBayesian__filter__matrix.html#a11">DenseMatrix</a>;
<a name="l00324"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a12">00324</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseColMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a12">DenseColMatrix</a>;
<a name="l00325"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a13">00325</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::SymMatrixWrapper&lt;detail::BaseDenseRowMatrix&gt; &gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a13">DenseSymMatrix</a>;
<a name="l00326"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a14">00326</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseUpperTriMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a14">DenseUTriMatrix</a>;
<a name="l00327"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a15">00327</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseLowerTriMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a15">DenseLTriMatrix</a>;
<a name="l00328"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a16">00328</a> <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseDiagMatrix&gt; <a class="code" href="namespaceBayesian__filter__matrix.html#a16">DenseDiagMatrix</a>;
00329 
00330                             <span class="comment">// Explicitly sparse types (any of the gappy types)</span>
00331 <span class="preprocessor">#ifdef BAYES_FILTER_GAPPY</span>
00332 <span class="preprocessor"></span><span class="keyword">typedef</span> FMVec&lt;detail::BaseSparseVector&gt; SparseVec;
00333 <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseDenseRowMatrix&gt; SparseRowMatrix;
00334 <span class="keyword">typedef</span> SparseRowMatrix SparseMatrix;
00335 <span class="keyword">typedef</span> FMMatrix&lt;detail::BaseSparseColMatrix&gt; SparseColMatrix;
00336 <span class="keyword">typedef</span> FMMatrix&lt;detail::SymMatrixWrapper&lt;detail::BaseSparseRowMatrix&gt; &gt; SparseSymMatrix;
00337 <span class="preprocessor">#endif</span>
00338 <span class="preprocessor"></span>
00339 
00340 <span class="comment">/*</span>
00341 <span class="comment"> * Matrix Adaptors, simply hide the uBLAS details</span>
00342 <span class="comment"> */</span>
00343 <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
00344 <span class="keyword">const</span> ublas::triangular_adaptor&lt;const M, ublas::upper&gt;
<a name="l00345"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a51">00345</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a51">UpperTri</a>(<span class="keyword">const</span> M&amp; m)
00346 <span class="comment">/*</span>
00347 <span class="comment"> * View Upper triangle of m</span>
00348 <span class="comment"> * ISSUE VC7 cannot cope with UTriMatrix::functor1_type</span>
00349 <span class="comment"> */</span>
00350 {
00351     <span class="keywordflow">return</span> ublas::triangular_adaptor&lt;const M, ublas::upper&gt;(m);
00352 }
00353 
00354 <span class="keyword">template</span> &lt;<span class="keyword">class</span> M&gt;
00355 <span class="keyword">const</span> ublas::triangular_adaptor&lt;const M, ublas::lower&gt;
<a name="l00356"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a52">00356</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a52">LowerTri</a>(<span class="keyword">const</span> M&amp; m)
00357 <span class="comment">/*</span>
00358 <span class="comment"> * View Lower triangle of m</span>
00359 <span class="comment"> */</span>
00360 {
00361     <span class="keywordflow">return</span> ublas::triangular_adaptor&lt;const M, ublas::lower&gt;(m);
00362 }
00363 
00364 
00365 
00366 <span class="comment">/*</span>
00367 <span class="comment"> * Matrix Support Operations</span>
00368 <span class="comment"> */</span>
00369 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
00370 ublas::matrix_vector_range&lt;FMMatrix&lt;Base&gt; &gt;
<a name="l00371"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a53">00371</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a53">diag</a>(FMMatrix&lt;Base&gt;&amp; M, std::size_t n)
00372 {   <span class="comment">// Return a vector proxy to the first n diagonal elements of M</span>
00373     <span class="keywordflow">return</span> ublas::matrix_vector_range&lt;FMMatrix&lt;Base&gt; &gt;(M, ublas::range(0,n), ublas::range(0,n));
00374 }
00375 
00376 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
00377 <span class="keyword">const</span> ublas::matrix_vector_range&lt;const FMMatrix&lt;Base&gt; &gt;
<a name="l00378"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a54">00378</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a53">diag</a>(<span class="keyword">const</span> FMMatrix&lt;Base&gt;&amp; M, std::size_t n)
00379 {   <span class="comment">// Return a vector proxy to the first n diagonal elements of M</span>
00380     <span class="keywordflow">return</span> ublas::matrix_vector_range&lt;const FMMatrix&lt;Base&gt; &gt;(M, ublas::range(0,n), ublas::range(0,n));
00381 }
00382 
00383 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
00384 ublas::matrix_vector_range&lt;FMMatrix&lt;Base&gt; &gt;
<a name="l00385"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a55">00385</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a53">diag</a>(FMMatrix&lt;Base&gt;&amp; M)
00386 {   <span class="comment">// Return a vector proxy to the diagonal elements of M</span>
00387     <span class="keyword">const</span> std::size_t common_size = std::min(M.size1(),M.size2());
00388     <span class="keywordflow">return</span> ublas::matrix_vector_range&lt;FMMatrix&lt;Base&gt; &gt;(M, ublas::range(0,common_size), ublas::range(0,common_size));
00389 }
00390 
00391 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
00392 <span class="keyword">const</span> ublas::matrix_vector_range&lt;const FMMatrix&lt;Base&gt; &gt;
<a name="l00393"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a56">00393</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a53">diag</a>(<span class="keyword">const</span> FMMatrix&lt;Base&gt;&amp; M)
00394 {   <span class="comment">// Return a vector proxy to the diagonal elements of M</span>
00395     <span class="keyword">const</span> std::size_t common_size = std::min(M.size1(),M.size2());
00396     <span class="keywordflow">return</span> ublas::matrix_vector_range&lt;const FMMatrix&lt;Base&gt; &gt;(M, ublas::range(0,common_size), ublas::range(0,common_size));
00397 }
00398 
00399 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base&gt;
<a name="l00400"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a57">00400</a> <span class="keywordtype">void</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a57">identity</a>(FMMatrix&lt;Base&gt;&amp; I)
00401 {   <span class="comment">// Set I to generalised Identity matrix. Clear I and set diag(I) to one</span>
00402     I.clear();
00403                             <span class="comment">// Set common diagonal elements</span>
00404     std::size_t common_size = std::min(I.size1(),I.size2());
00405     <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::value_type Base_value_type;
00406     <a class="code" href="namespaceBayesian__filter__matrix.html#a53">diag</a>(I) = ublas::scalar_vector&lt;Base_value_type&gt;(common_size, Base_value_type(1));
00407 }
00408 
00409 
00410 
00411 <span class="comment">/*</span>
00412 <span class="comment"> * Symmetric Positive (Semi) Definate multiplication: X*S*X' and X'*S*X</span>
00413 <span class="comment"> *  The name is slightly misleading. The result is actually only PD if S is PD</span>
00414 <span class="comment"> *  Algorithms are intended to exploit the symmerty of the result</span>
00415 <span class="comment"> *  and also where possible the row by row multiplication inherent in X*X'</span>
00416 <span class="comment"> */</span>
00417 
00418 <span class="keyword">namespace </span>detail {      <span class="comment">// mult_SPD now an implementation detail</span>
00419     
00420 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixX&gt;
<a name="l00421"></a><a class="code" href="namespaceBayesian__filter__matrix_1_1detail.html#a12">00421</a> <span class="keywordtype">void</span> <a class="code" href="namespaceBayesian__filter__matrix_1_1detail.html#a12">mult_SPD</a> (<span class="keyword">const</span> MatrixX&amp; X, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>&amp; s, <a class="code" href="namespaceBayesian__filter__matrix.html#a5">SymMatrix</a>&amp; P)
00422 <span class="comment">/*</span>
00423 <span class="comment"> * Symmetric Positive (Semi) Definate multiply: P += X*diag_matrix(s)*X'</span>
00424 <span class="comment"> */</span>
00425 {
00426     Vec::const_iterator si, send = s.end();
00427     <span class="keyword">typename</span> MatrixX::const_iterator1 Xa = X.begin1();
00428     <span class="keyword">const</span> <span class="keyword">typename</span> MatrixX::const_iterator1 Xend = X.end1();
00429     <span class="keyword">typename</span> MatrixX::const_iterator1 Xb;
00430 
00431     <span class="comment">// P(a,b) = X.row(a) * X.row(b)</span>
00432     <span class="keywordflow">for</span> (; Xa != Xend; ++Xa)                <span class="comment">// Iterate Rows</span>
00433     {
00434         <span class="keyword">typename</span> MatrixX::const_Row Xav = MatrixX::rowi(Xa);
00435         Xb = Xa;                            <span class="comment">// Start at the row Xa only one triangle of symetric result required</span>
00436         <span class="keywordflow">for</span> (; Xb != Xend; ++Xb)
00437         {
00438             SymMatrix::value_type p = 0;    <span class="comment">// Tripple vector inner product</span>
00439             <span class="keyword">typename</span> MatrixX::const_Row Xbv = MatrixX::rowi(Xb);
00440             <span class="keywordflow">for</span> (si = s.begin(); si != send; ++si) {
00441                 Vec::size_type i = si.index();
00442                 p += Xav[i] * (*si) * Xbv[i];
00443             }
00444             P(Xa.index1(),Xb.index1()) += p;
00445         }
00446     }
00447 }
00448 
00449 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixX&gt;
<a name="l00450"></a><a class="code" href="namespaceBayesian__filter__matrix_1_1detail.html#a13">00450</a> <span class="keywordtype">void</span> <a class="code" href="namespaceBayesian__filter__matrix_1_1detail.html#a13">mult_SPDT</a> (<span class="keyword">const</span> MatrixX&amp; X, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>&amp; s, <a class="code" href="namespaceBayesian__filter__matrix.html#a5">SymMatrix</a>&amp; P)
00451 <span class="comment">/*</span>
00452 <span class="comment"> * Symmetric Positive (Semi) Definate multiply: P += X'*diag_matrix(s)*X</span>
00453 <span class="comment"> */</span>
00454 {
00455     Vec::const_iterator si, send = s.end();
00456     <span class="keyword">typename</span> MatrixX::const_iterator2 Xa = X.begin2();
00457     <span class="keyword">const</span> <span class="keyword">typename</span> MatrixX::const_iterator2 Xend = X.end2();
00458     <span class="keyword">typename</span> MatrixX::const_iterator2 Xb;
00459 
00460     <span class="comment">// P(a,b) = X.col(a) * X.col(b)</span>
00461     <span class="keywordflow">for</span> (; Xa != Xend; ++Xa)                <span class="comment">// Iterate vectors</span>
00462     {
00463         <span class="keyword">typename</span> MatrixX::const_Column Xav = MatrixX::columni(Xa);
00464         Xb = Xa;                            <span class="comment">// Start at the row Xa only one triangle of symertric result required</span>
00465         <span class="keywordflow">for</span> (; Xb != Xend; ++Xb)
00466         {                                   <span class="comment">// Tripple vector inner product</span>
00467             SymMatrix::value_type p = 0;
00468             <span class="keyword">typename</span> MatrixX::const_Column Xbv = MatrixX::columni(Xb);
00469             <span class="keywordflow">for</span> (si = s.begin(); si != send; ++si) {
00470                 Vec::size_type i = si.index();
00471                 p += Xav[i] * (*si) * Xbv[i];
00472             }
00473             P(Xa.index2(),Xb.index2()) += p;
00474         }
00475     }
00476 }
00477 
00478 }<span class="comment">//namespace detail</span>
00479 
00480 
00481 <span class="comment">/*</span>
00482 <span class="comment"> * prod_SPD - uBLAS Expression templates for X*X' and X*X'</span>
00483 <span class="comment"> * Functions are only defined for the type for which the operation is efficient</span>
00484 <span class="comment"> * ISSUE Although numerically symmetric, uBlas has no expression type to represent this property</span>
00485 <span class="comment"> *  The result must be assigned to a symmetric container to exploit the symmetry</span>
00486 <span class="comment"> */</span>
00487 
00488 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E1, <span class="keyword">class</span> E2&gt;
<a name="l00489"></a><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html">00489</a> <span class="keyword">struct </span><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html">prod_expression_result</a>
00490 {   <span class="comment">// Provide ET result E1E2T_type of prod(matrix_expression&lt;E1&gt;,trans(matrix_expression&lt;E2&gt;)</span>
<a name="l00491"></a><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w0">00491</a>     <span class="keyword">typedef</span> BOOST_UBLAS_TYPENAME ublas::matrix_unary2_traits&lt;E2, ublas::scalar_identity&lt;BOOST_UBLAS_TYPENAME E2::value_type&gt; &gt;::result_type  <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w0">E2T_type</a>;
00492     <span class="keyword">typedef</span> BOOST_UBLAS_TYPENAME ublas::matrix_matrix_binary_traits&lt;BOOST_UBLAS_TYPENAME E1::value_type, E1,
<a name="l00493"></a><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w1">00493</a>                                         BOOST_UBLAS_TYPENAME E2T_type::value_type, <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w0">E2T_type</a>&gt;::result_type  <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w1">E1E2T_type</a>;
00494 
00495     <span class="comment">// Provide ET result E1TE2_type of prod(trans(matrix_expression&lt;E1&gt;),matrix_expression&lt;E2&gt;)</span>
<a name="l00496"></a><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w2">00496</a>     <span class="keyword">typedef</span> BOOST_UBLAS_TYPENAME ublas::matrix_unary2_traits&lt;E1, ublas::scalar_identity&lt;BOOST_UBLAS_TYPENAME E1::value_type&gt; &gt;::result_type  <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w2">E1T_type</a>;
00497     <span class="keyword">typedef</span> BOOST_UBLAS_TYPENAME ublas::matrix_matrix_binary_traits&lt;BOOST_UBLAS_TYPENAME E1T_type::value_type, <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w2">E1T_type</a>,
<a name="l00498"></a><a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w3">00498</a>                                         BOOST_UBLAS_TYPENAME E2::value_type, E2&gt;::result_type  <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html#w3">E1TE2_type</a>;
00499 };
00500 
00501  
00502 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt; <span class="keyword">inline</span>
00503 <span class="keyword">typename</span> <a class="code" href="structBayesian__filter__matrix_1_1prod__expression__result.html">prod_expression_result&lt;E,E&gt;</a>::E1E2T_type
<a name="l00504"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a58">00504</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a58">prod_SPD</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; X)
00505 <span class="comment">/*</span>
00506 <span class="comment"> * Symmetric Positive (Semi) Definate product: X*X'</span>
00507 <span class="comment"> */</span>
00508 {
00509     <span class="comment">// ISSUE: uBLAS post Boost 1_31_0 introduces a trans(const matrix_expression&lt;E&gt;&amp; e) which propogates the const expression type</span>
00510     <span class="comment">// Bypass this to avoid having to detect the Boost version</span>
00511     <span class="keywordflow">return</span> prod( X, trans(<span class="keyword">const_cast</span>&lt;ublas::matrix_expression&lt;E&gt;&amp;&gt;(X) ));
00512 }
00513 
00514 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EX, <span class="keyword">class</span> ES, <span class="keyword">class</span> ET&gt; <span class="keyword">inline</span>
00515 <span class="keyword">typename</span> prod_expression_result&lt;EX,ET&gt;::E1E2T_type
<a name="l00516"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a59">00516</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a58">prod_SPD</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;EX&gt;&amp; X, <span class="keyword">const</span> ublas::matrix_expression&lt;ES&gt;&amp; S, ublas::matrix_expression&lt;ET&gt;&amp; XStemp)
00517 <span class="comment">/*</span>
00518 <span class="comment"> * Symmetric Positive (Semi) Definate product: X*(X*S)', XStemp = X*S</span>
00519 <span class="comment"> *  Result symmetric if S is symmetric</span>
00520 <span class="comment"> */</span>
00521 {
00522     <span class="keywordflow">return</span> prod( X, trans(prod(X,S,XStemp())) );
00523 }
00524 
00525 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EX, <span class="keyword">class</span> ES, <span class="keyword">class</span> ET&gt; <span class="keyword">inline</span>
<a name="l00526"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a60">00526</a> ET <a class="code" href="namespaceBayesian__filter__matrix.html#a58">prod_SPD</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;EX&gt;&amp; X, <span class="keyword">const</span> ublas::vector_expression&lt;ES&gt;&amp; s, ublas::matrix_expression&lt;ET&gt;&amp; Ptemp)
00527 <span class="comment">/*</span>
00528 <span class="comment"> * Symmetric Positive (Semi) Definate product: X*diag_matrix(s)*X', Ptemp = return value</span>
00529 <span class="comment"> * Precond: Ptemp must be size conformant with the product</span>
00530 <span class="comment"> * TODO requires a prod_diag(X,s)</span>
00531 <span class="comment"> */</span>
00532 {
00533     <span class="keyword">const</span> EX&amp; XX = X();
00534     Vec::const_iterator si, send = s().end();
00535     <span class="keyword">typename</span> EX::const_iterator1 Xa = XX.begin1();
00536     <span class="keyword">const</span> <span class="keyword">typename</span> EX::const_iterator1 Xend = XX.end1();
00537     <span class="keyword">typename</span> EX::const_iterator1 Xb;
00538 
00539     <span class="comment">// P(a,b) = sum(X.row(a) * s * X.row(b))</span>
00540     <span class="keywordflow">for</span> (; Xa != Xend; ++Xa)        <span class="comment">// Iterate rows</span>
00541     {
00542         <span class="keyword">typedef</span> <span class="keyword">const</span> ublas::matrix_row&lt;const EX&gt; EX_row;
00543         EX_row Xav (ublas::row_const(XX, Xa.index1()));
00544         Xb = Xa;                            <span class="comment">// Start at the row Xa only one triangle of symetric result required</span>
00545         <span class="keywordflow">for</span> (; Xb != Xend; ++Xb)
00546         {
00547             <span class="keyword">typename</span> EX::value_type p = 0;  <span class="comment">// Triple vector inner product</span>
00548             EX_row Xbv (ublas::row_const(XX, Xb.index1()));
00549             <span class="keywordflow">for</span> (si = s().begin(); si != send; ++si) {
00550                 Vec::size_type i = si.index();
00551                 p += Xav[i] * (*si) * Xbv[i];
00552             }
00553             Ptemp()(Xa.index1(),Xb.index1()) = p;
00554             Ptemp()(Xb.index1(),Xa.index1()) = p;
00555         }
00556     }
00557     <span class="keywordflow">return</span> Ptemp();
00558 }
00559 
00560 
00561 <span class="keyword">template</span>&lt;<span class="keyword">class</span> E&gt; <span class="keyword">inline</span>
00562 <span class="keyword">typename</span> prod_expression_result&lt;E,E&gt;::E1TE2_type
<a name="l00563"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a61">00563</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a61">prod_SPDT</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;E&gt;&amp; X)
00564 <span class="comment">/*</span>
00565 <span class="comment"> * Symmetric Positive (Semi) Definate product: X'*X</span>
00566 <span class="comment"> */</span>
00567 {
00568     <span class="comment">// ISSUE: See prod_SPD</span>
00569     <span class="keywordflow">return</span> prod( trans(<span class="keyword">const_cast</span>&lt;ublas::matrix_expression&lt;E&gt;&amp;&gt;(X) ), X);
00570 }
00571 
00572 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EX, <span class="keyword">class</span> ES, <span class="keyword">class</span> ET&gt; <span class="keyword">inline</span>
00573 <span class="keyword">typename</span> prod_expression_result&lt;ET,EX&gt;::E1TE2_type
<a name="l00574"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a62">00574</a>  <a class="code" href="namespaceBayesian__filter__matrix.html#a61">prod_SPDT</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;EX&gt;&amp; X, <span class="keyword">const</span> ublas::matrix_expression&lt;ES&gt;&amp; S, ublas::matrix_expression&lt;ET&gt;&amp; SXtemp)
00575 <span class="comment">/*</span>
00576 <span class="comment"> * Symmetric Positive (Semi) Definate product: (S*X)'*X, SXtemp = S*X</span>
00577 <span class="comment"> *  Result symmetric if S is symmetric</span>
00578 <span class="comment"> */</span>
00579 {
00580     <span class="keywordflow">return</span> prod( trans(prod(S,X,SXtemp())), X);
00581 }
00582 
00583 <span class="keyword">template</span>&lt;<span class="keyword">class</span> EX, <span class="keyword">class</span> ES, <span class="keyword">class</span> ET&gt; <span class="keyword">inline</span>
<a name="l00584"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a63">00584</a> ET <a class="code" href="namespaceBayesian__filter__matrix.html#a61">prod_SPDT</a> (<span class="keyword">const</span> ublas::matrix_expression&lt;EX&gt;&amp; X, <span class="keyword">const</span> ublas::vector_expression&lt;ES&gt;&amp; s, ublas::matrix_expression&lt;ET&gt;&amp; Ptemp)
00585 <span class="comment">/*</span>
00586 <span class="comment"> * Symmetric Positive (Semi) Definate product: X'*diag_matrix(s)*X, Ptemp = return value</span>
00587 <span class="comment"> * Precond: Ptemp must be size conformant with the product</span>
00588 <span class="comment"> * TODO requires a prod_diag(X,s)</span>
00589 <span class="comment"> */</span>
00590 {
00591     <span class="keyword">const</span> EX&amp; XX = X();
00592     Vec::const_iterator si, send = s().end();
00593     <span class="keyword">typename</span> EX::const_iterator2 Xa = X.begin2();
00594     <span class="keyword">const</span> <span class="keyword">typename</span> EX::const_iterator2 Xend = X.end2();
00595     <span class="keyword">typename</span> EX::const_iterator2 Xb;
00596 
00597     <span class="comment">// P(a,b) = sum(X.col(a) * s * X.col(b))</span>
00598     <span class="keywordflow">for</span> (; Xa != Xend; ++Xa)        <span class="comment">// Iterate columns</span>
00599     {
00600         <span class="keyword">typedef</span> <span class="keyword">const</span> ublas::matrix_column&lt;const EX&gt; EX_column;
00601         EX_column Xav = ublas::column_const(XX, Xa.index2());
00602         Xb = Xa;                            <span class="comment">// Start at the column Xa only one triangle of symetric result required</span>
00603         <span class="keywordflow">for</span> (; Xb != Xend; ++Xb)
00604         {
00605             <span class="keyword">typename</span> EX::value_type p = 0;  <span class="comment">// Triple vector inner product</span>
00606             EX_column Xbv = ublas::column_const(XX, Xb.index2());
00607             <span class="keywordflow">for</span> (si = s().begin(); si != send; ++si) {
00608                 Vec::size_type i = si.index();
00609                 p += Xav[i] * (*si) * Xbv[i];
00610             }
00611             Ptemp()(Xa.index2(),Xb.index2()) = p;
00612             Ptemp()(Xb.index2(),Xa.index2()) = p;
00613         }
00614     }
00615     <span class="keywordflow">return</span> Ptemp();
00616 }
00617 
<a name="l00618"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a64">00618</a> <span class="keyword">inline</span> Vec::value_type <a class="code" href="namespaceBayesian__filter__matrix.html#a61">prod_SPDT</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>&amp; x, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>&amp; s)
00619 <span class="comment">/*</span>
00620 <span class="comment"> * Symmetric Positive (Semi) Definate product: x'*diag_matrix(s)*x</span>
00621 <span class="comment"> */</span>
00622 {
00623     <span class="keyword">const</span> Vec::const_iterator xi_end = x.end();
00624     Vec::const_iterator si = s.begin();
00625     Vec::const_iterator xi=x.begin();
00626     Vec::value_type p = Vec::value_type(0);
00627     <span class="keywordflow">while</span> (xi != xi_end)
00628     {
00629         p += (*xi) * (*si) * (*xi);
00630         ++xi; ++ si;
00631     }
00632     
00633     <span class="keywordflow">return</span> p;
00634 }
00635 
<a name="l00636"></a><a class="code" href="namespaceBayesian__filter__matrix.html#a65">00636</a> <span class="keyword">inline</span> Vec::value_type <a class="code" href="namespaceBayesian__filter__matrix.html#a61">prod_SPDT</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">Vec</a>&amp; x, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a5">SymMatrix</a>&amp; S)
00637 <span class="comment">/*</span>
00638 <span class="comment"> * Symmetric Positive (Semi) Definate multiply: p = x'*S*x</span>
00639 <span class="comment"> */</span>
00640 {
00641     <span class="keywordflow">return</span> inner_prod (x, prod(S,x) );
00642 }
00643 
00644 }<span class="comment">//namespace</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 19:23:17 2005 for Bayes++ Bayesian Filtering Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
