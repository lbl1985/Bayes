<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Bayes++ Bayesian Filtering Classes: bayesFlt.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>bayesFlt.hpp</h1><a href="bayesFlt_8hpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#ifndef _BAYES_FILTER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define _BAYES_FILTER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/*</span>
00005 <span class="comment"> * Bayes++ the Bayesian Filtering Library</span>
00006 <span class="comment"> * Copyright (c) 2002 Michael Stevens</span>
00007 <span class="comment"> * See accompanying Bayes++.htm for terms and conditions of use.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * $Header: /cvsroot/bayesclasses/Bayes++/BayesFilter/bayesFlt.hpp,v 1.24.2.2 2004/07/18 18:38:04 mistevens Exp $</span>
00010 <span class="comment"> * $NoKeywords: $</span>
00011 <span class="comment"> */</span>
00012 
00013 <span class="comment">/*</span>
00014 <span class="comment"> * Bayesian filtering reresented as Dual heirarchy of:</span>
00015 <span class="comment"> *  Prediction and Observation models</span>
00016 <span class="comment"> *  Filtering Schemes</span>
00017 <span class="comment"> */</span>
00018  
00019 <span class="comment">// Common headers required for declerations</span>
00020 <span class="preprocessor">#include "<a class="code" href="bayesException_8hpp.html">bayesException.hpp</a>"</span>   <span class="comment">// exception types</span>
00021 <span class="preprocessor">#include "<a class="code" href="matSupSub_8hpp.html">matSupSub.hpp</a>"</span>            <span class="comment">// matrix support subsystem</span>
00022 
00023 <span class="comment">/* Filter namespace */</span>
00024 <span class="keyword">namespace </span>Bayesian_filter
00025 {
00026     <span class="comment">// Allow use of a short name for matrix namespace</span>
00027     <span class="keyword">namespace </span>FM = Bayesian_filter_matrix;
00028 
00029 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * Abstraction support classes, at the base of the heirarchy</span>
00032 <span class="comment"> */</span>
00033 
<a name="l00034"></a><a class="code" href="classBayesian__filter_1_1Bayes__base.html">00034</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a> {
00035 <span class="comment">/*</span>
00036 <span class="comment"> * A very abstract Polymorphic base representation!</span>
00037 <span class="comment"> * Interface provides: type, internal error handing, and destruction</span>
00038 <span class="comment"> */</span>
00039 <span class="keyword">public</span>:
<a name="l00040"></a><a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">00040</a>     <span class="keyword">typedef</span> Bayesian_filter_matrix::Float <a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Float</a>;
00041     <span class="comment">// Type used thoughout as a number representation for state etc</span>
00042 
00043     <span class="keyword">virtual</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html#a0">~Bayes_base</a>() = 0;
00044     <span class="comment">// Polymorphic</span>
00045 
00046     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html#e0">error</a> (<span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1Numeric__exception.html">Numeric_exception</a>&amp; a);
00047     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html#e0">error</a> (<span class="keyword">const</span> <a class="code" href="classBayesian__filter_1_1Logic__exception.html">Logic_exception</a>&amp; a);
00048     <span class="comment">// Report a filter, throw a Filter_exception</span>
00049     <span class="comment">//  No exception saftey rules are specified, assume the object is invalid</span>
00050     <span class="comment">// May have side effects for debuging</span>
00051 };
00052 
00053 
<a name="l00054"></a><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">00054</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">Numerical_rcond</a>
00055 <span class="comment">/*</span>
00056 <span class="comment"> * Numerical comparison of reciprocal condition numbers</span>
00057 <span class="comment"> *  Required for all linear algebra in models and filters</span>
00058 <span class="comment"> *  Implements minimum allowable reciprocal condition number for PD Matrix factorisations</span>
00059 <span class="comment"> */</span>
00060 {
00061 <span class="keyword">public</span>:
<a name="l00062"></a><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a0">00062</a>     <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a0">Numerical_rcond</a>()
00063     {   limit_PD = limit_PD_init;
00064     }
<a name="l00065"></a><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a1">00065</a>     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a1">set_limit_PD</a>(<a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Bayes_base::Float</a> nl)
00066     {   limit_PD = nl;
00067     }
<a name="l00068"></a><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a2">00068</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a2">check_PSD</a> (<a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Bayes_base::Float</a> rcond, <span class="keyword">const</span> <span class="keywordtype">char</span>* error_description) <span class="keyword">const</span>
00069     <span class="comment">/* Checks a the reciprocal condition number</span>
00070 <span class="comment">     * Generates a Bayes_filter_exception if value represents a NON PSD matrix</span>
00071 <span class="comment">     * Inverting condition provides a test for IEC 559 NaN values</span>
00072 <span class="comment">     */</span>
00073     {   <span class="keywordflow">if</span> (!(rcond &gt;= 0))
00074             Bayes_base::error (<a class="code" href="classBayesian__filter_1_1Numeric__exception.html">Numeric_exception</a> (error_description));
00075     }
00076 
<a name="l00077"></a><a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a3">00077</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html#a3">check_PD</a> (<a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Bayes_base::Float</a> rcond, <span class="keyword">const</span> <span class="keywordtype">char</span>* error_description) <span class="keyword">const</span>
00078     <span class="comment">/* Checks a reciprocal condition number</span>
00079 <span class="comment">     * Generates a Bayes_filter_exception if value represents a NON PD matrix</span>
00080 <span class="comment">     * I.e. rcond is bellow given conditioning limit</span>
00081 <span class="comment">     * Inverting condition provides a test for IEC 559 NaN values</span>
00082 <span class="comment">     */</span>
00083     {   <span class="keywordflow">if</span> (!(rcond &gt;= limit_PD))
00084             Bayes_base::error (<a class="code" href="classBayesian__filter_1_1Numeric__exception.html">Numeric_exception</a> (error_description));
00085     }
00086 <span class="keyword">private</span>:
00087     <a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Bayes_base::Float</a> limit_PD;     
00088     <span class="keyword">const</span> <span class="keyword">static</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html#w0">Bayes_base::Float</a> limit_PD_init;   <span class="comment">// Initial common value for limit_PD</span>
00089 };
00090 
00091 
00092 <span class="comment">/*</span>
00093 <span class="comment"> * Abstract Prediction models</span>
00094 <span class="comment"> *  Predict models are used to parameterise predict functions of filters</span>
00095 <span class="comment"> */</span>
<a name="l00096"></a><a class="code" href="classBayesian__filter_1_1Predict__model__base.html">00096</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Predict__model__base.html">Predict_model_base</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a>
00097 {
00098     <span class="comment">// Empty</span>
00099 };
00100 
00101 
<a name="l00102"></a><a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">00102</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">Sampled_predict_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Predict__model__base.html">Predict_model_base</a>
00103 <span class="comment">/* Sampled stochastic predict model</span>
00104 <span class="comment">    x*(k) = fw(x(k-1), w(k))</span>
00105 <span class="comment">   fw should generate samples from the stochastic variable w(k)</span>
00106 <span class="comment">   This fundamental model is used instead of the predict likelihood function L(x*|x)</span>
00107 <span class="comment">   Since drawing samples from an arbitary L is non-trivial (see MCMC theory)</span>
00108 <span class="comment">   the burden is place on the model to generate these samples.</span>
00109 <span class="comment">   Defines an Interface without data members</span>
00110 <span class="comment"> */</span>
00111 {
00112 <span class="keyword">public</span>:
00113     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html#a0">fw</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00114     <span class="comment">// Note: Reference return value as a speed optimisation, MUST be copied by caller.</span>
00115 };
00116 
<a name="l00117"></a><a class="code" href="classBayesian__filter_1_1Functional__predict__model.html">00117</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Functional__predict__model.html">Functional_predict_model</a> :<span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Predict__model__base.html">Predict_model_base</a>
00118 <span class="comment">/* Functional (non-stochastic) predict model f</span>
00119 <span class="comment">    x*(k) = fx(x(k-1))</span>
00120 <span class="comment">   This fundamental model is used instead of the predict likelihood function L(x*|x)</span>
00121 <span class="comment">   Since L is a delta function which isn't much use for numerical systems.</span>
00122 <span class="comment">   Defines an Interface without data members</span>
00123 <span class="comment"> */</span>
00124 {
00125 <span class="keyword">public</span>:
00126     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Functional__predict__model.html#a0">fx</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00127     <span class="comment">// Functional model</span>
00128     <span class="comment">// Note: Reference return value as a speed optimisation, MUST be copied by caller.</span>
00129     
<a name="l00130"></a><a class="code" href="classBayesian__filter_1_1Functional__predict__model.html#a1">00130</a>     <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Functional__predict__model.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x)<span class="keyword"> const</span>
00131 <span class="keyword">    </span>{   <span class="comment">// Operator form of functional model</span>
00132         <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter_1_1Functional__predict__model.html#a0">fx</a>(x);
00133     }
00134 };
00135 
<a name="l00136"></a><a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html">00136</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html">Gaussian_predict_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Predict__model__base.html">Predict_model_base</a>
00137 <span class="comment">/* Gaussian noise predict model</span>
00138 <span class="comment">   This fundamental noise model for linear/linearised filtering</span>
00139 <span class="comment">    x(k|k-1) = x(k-1|k-1)) + G(k)w(k)</span>
00140 <span class="comment">    G(k)w(k)</span>
00141 <span class="comment">    q(k) = state noise covariance, q(k) is covariance of w(k)</span>
00142 <span class="comment">    G(k) = state noise coupling</span>
00143 <span class="comment">*/</span>
00144 {
00145 <span class="keyword">public</span>:
00146     <a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#a0">Gaussian_predict_model</a> (std::size_t x_size, std::size_t q_size);
00147 
<a name="l00148"></a><a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o0">00148</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o0">q</a>;      <span class="comment">// Noise variance (always dense, use coupling to represent sparseness)</span>
<a name="l00149"></a><a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o1">00149</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a3">FM::Matrix</a> <a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o1">G</a>;       <span class="comment">// Noise Coupling</span>
00150     
<a name="l00151"></a><a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o2">00151</a>     <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">Numerical_rcond</a> <a class="code" href="classBayesian__filter_1_1Gaussian__predict__model.html#o2">rclimit</a>;
00152     <span class="comment">// Reciprocal condition number limit of linear components when factorised or inverted</span>
00153 };
00154 
<a name="l00155"></a><a class="code" href="classBayesian__filter_1_1Addative__predict__model.html">00155</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Addative__predict__model.html">Addative_predict_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Predict__model__base.html">Predict_model_base</a>
00156 <span class="comment">/* Addative Gaussian noise predict model</span>
00157 <span class="comment">   This fundamental model for non-linear filtering with addative noise</span>
00158 <span class="comment">    x(k|k-1) = f(x(k-1|k-1)) + G(k)w(k)</span>
00159 <span class="comment">    q(k) = state noise covariance, q(k) is covariance of w(k)</span>
00160 <span class="comment">    G(k) = state noise coupling</span>
00161 <span class="comment">   ISSUE Should be privately derived from Gaussian_predict_model but access control in GCC is broken</span>
00162 <span class="comment">*/</span>
00163 {
00164 <span class="keyword">public</span>:
00165     <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#a0">Addative_predict_model</a> (std::size_t x_size, std::size_t q_size);
00166 
00167     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#a1">f</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00168     <span class="comment">// Functional part of addative model</span>
00169     <span class="comment">// Note: Reference return value as a speed optimisation, MUST be copied by caller.</span>
00170 
<a name="l00171"></a><a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o0">00171</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o0">q</a>;      <span class="comment">// Noise variance (always dense, use coupling to represent sparseness)</span>
<a name="l00172"></a><a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o1">00172</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a3">FM::Matrix</a> <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o1">G</a>;       <span class="comment">// Noise Coupling</span>
00173 
<a name="l00174"></a><a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o2">00174</a>     <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">Numerical_rcond</a> <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html#o2">rclimit</a>;
00175     <span class="comment">// Reciprocal condition number limit of linear components when factorised or inverted</span>
00176 };
00177 
<a name="l00178"></a><a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html">00178</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html">Linrz_predict_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Addative__predict__model.html">Addative_predict_model</a>
00179 <span class="comment">/* Linrz predict model</span>
00180 <span class="comment">   This fundamental model for linear/linearised filtering</span>
00181 <span class="comment">    x(k|k-1) = f(x(k-1|k-1)</span>
00182 <span class="comment">    Fx(x(k-1|k-1) = Jacobian of of functional part fx with respect to state x</span>
00183 <span class="comment"> */</span>
00184 {
00185 <span class="keyword">public</span>:
00186     <a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html#a0">Linrz_predict_model</a> (std::size_t x_size, std::size_t q_size);
<a name="l00187"></a><a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html#o0">00187</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a3">FM::Matrix</a> <a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html#o0">Fx</a>;      <span class="comment">// Model</span>
00188 };
00189 
<a name="l00190"></a><a class="code" href="classBayesian__filter_1_1Linear__predict__model.html">00190</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linear__predict__model.html">Linear_predict_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html">Linrz_predict_model</a>
00191 <span class="comment">/* Linear predict model</span>
00192 <span class="comment">   Enforces linearity on f</span>
00193 <span class="comment">    x(k|k-1) = Fx(k-1|k-1) * x(k-1|k-1)</span>
00194 <span class="comment"> */</span>
00195 {
00196 <span class="keyword">public</span>:
00197     <a class="code" href="classBayesian__filter_1_1Linear__predict__model.html#a0">Linear_predict_model</a> (std::size_t x_size, std::size_t q_size);
<a name="l00198"></a><a class="code" href="classBayesian__filter_1_1Linear__predict__model.html#a1">00198</a>     <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Linear__predict__model.html#a1">f</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x)<span class="keyword"> const</span>
00199 <span class="keyword">    </span>{   <span class="comment">// Provide the linear implementation of functional f</span>
00200         xp.assign (FM::prod(Fx,x));
00201         <span class="keywordflow">return</span> xp;
00202     }
00203 <span class="keyword">private</span>:
00204     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> xp;
00205 };
00206 
<a name="l00207"></a><a class="code" href="classBayesian__filter_1_1Linear__invertable__predict__model.html">00207</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linear__invertable__predict__model.html">Linear_invertable_predict_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linear__predict__model.html">Linear_predict_model</a>
00208 <span class="comment">/* Linear invertable predict model</span>
00209 <span class="comment">   Fx has an inverse</span>
00210 <span class="comment">    x(k-1|k-1) = inv.Fx(k-1|k-1) * x(k|k-1)</span>
00211 <span class="comment"> */</span>
00212 {
00213 <span class="keyword">public</span>:
00214     <a class="code" href="classBayesian__filter_1_1Linear__invertable__predict__model.html#a0">Linear_invertable_predict_model</a> (std::size_t x_size, std::size_t q_size);
<a name="l00215"></a><a class="code" href="structBayesian__filter_1_1Linear__invertable__predict__model_1_1inverse__model.html">00215</a>     <span class="keyword">struct </span><a class="code" href="structBayesian__filter_1_1Linear__invertable__predict__model_1_1inverse__model.html">inverse_model</a> {
00216         <a class="code" href="structBayesian__filter_1_1Linear__invertable__predict__model_1_1inverse__model.html#a0">inverse_model</a> (std::size_t x_size);
<a name="l00217"></a><a class="code" href="structBayesian__filter_1_1Linear__invertable__predict__model_1_1inverse__model.html#o0">00217</a>         <a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a> <a class="code" href="structBayesian__filter_1_1Linear__invertable__predict__model_1_1inverse__model.html#o0">Fx</a>;   <span class="comment">// Model inverse (ColMatrix as usually transposed)</span>
00218     } <a class="code" href="classBayesian__filter_1_1Linear__invertable__predict__model.html#o0">inv</a>;
00219 };
00220 
00221 
00222 
00223 <span class="comment">/*</span>
00224 <span class="comment"> * Abstract Observation models</span>
00225 <span class="comment"> *  Observe models are used to parameterise the observe functions of filters</span>
00226 <span class="comment"> */</span>
<a name="l00227"></a><a class="code" href="classBayesian__filter_1_1Observe__model__base.html">00227</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Observe__model__base.html">Observe_model_base</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a>
00228 {
00229     <span class="comment">// Empty</span>
00230 };
00231 
<a name="l00232"></a><a class="code" href="classBayesian__filter_1_1Observe__function.html">00232</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Observe__function.html">Observe_function</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a>
00233 <span class="comment">// Function object for predict of observations</span>
00234 {
00235 <span class="keyword">public</span>:
00236     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Observe__function.html#a0">h</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00237     <span class="comment">// Note: Reference return value as a speed optimisation, MUST be copied by caller.</span>
00238 };
00239 
00240 
<a name="l00241"></a><a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html">00241</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html">Likelihood_observe_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__model__base.html">Observe_model_base</a>
00242 <span class="comment">/* Likelihood observe model L(z |x)</span>
00243 <span class="comment"> *  The most fundamental Bayesian definition of an observation</span>
00244 <span class="comment"> * Defines an Interface without data members</span>
00245 <span class="comment"> */</span>
00246 {
00247 <span class="keyword">public</span>:
<a name="l00248"></a><a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#a0">00248</a>     <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#a0">Likelihood_observe_model</a>(std::size_t z_size) : <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#p0">z</a>(z_size)
00249     {}
00250     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#a1">L</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00251     <span class="comment">// Likelihood L(z | x)</span>
00252 
<a name="l00253"></a><a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#a2">00253</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#a2">Lz</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; zz)
00254     <span class="comment">// Set the observation zz about which to evaluate the Likelihood function</span>
00255     {
00256         <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#p0">z</a> = zz;
00257     }
00258 <span class="keyword">protected</span>:
<a name="l00259"></a><a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#p0">00259</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html#p0">z</a>;          <span class="comment">// z set by Lz</span>
00260 };
00261 
<a name="l00262"></a><a class="code" href="classBayesian__filter_1_1Functional__observe__model.html">00262</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Functional__observe__model.html">Functional_observe_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__model__base.html">Observe_model_base</a>, <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__function.html">Observe_function</a>
00263 <span class="comment">/* Functional (non-stochastic) observe model h</span>
00264 <span class="comment"> *  zp(k) = hx(x(k|k-1))</span>
00265 <span class="comment"> * This is a seperate fundamental model and not derived from likelihood because:</span>
00266 <span class="comment"> *  L is a delta function which isn't much use for numerical systems</span>
00267 <span class="comment"> * Defines an Interface without data members</span>
00268 <span class="comment"> */</span>
00269 {
00270 <span class="keyword">public</span>:
<a name="l00271"></a><a class="code" href="classBayesian__filter_1_1Functional__observe__model.html#a0">00271</a>     <a class="code" href="classBayesian__filter_1_1Functional__observe__model.html#a0">Functional_observe_model</a>(std::size_t <span class="comment">/*z_size*/</span>)
00272     {}
<a name="l00273"></a><a class="code" href="classBayesian__filter_1_1Functional__observe__model.html#a1">00273</a>     <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Functional__observe__model.html#a1">operator()</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x)<span class="keyword"> const</span>
00274 <span class="keyword">    </span>{   <span class="keywordflow">return</span> <a class="code" href="classBayesian__filter_1_1Observe__function.html#a0">h</a>(x);
00275     }
00276 
00277 };
00278 
<a name="l00279"></a><a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">00279</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">Parametised_observe_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__model__base.html">Observe_model_base</a>, <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__function.html">Observe_function</a>
00280 <span class="comment">/* Observation model parametised with a fixed z size</span>
00281 <span class="comment"> *  Includes the functional part of a noise model</span>
00282 <span class="comment"> *  Model is assume to have linear and non-linear components</span>
00283 <span class="comment"> *  Linear components need to be checked for conditioning</span>
00284 <span class="comment"> *  Non-linear components may be discontinous and need normalisation</span>
00285 <span class="comment"> */</span>
00286 {
00287 <span class="keyword">public</span>:
<a name="l00288"></a><a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#a0">00288</a>     <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#a0">Parametised_observe_model</a>(std::size_t <span class="comment">/*z_size*/</span>)
00289     {}
00290     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#a1">h</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x) <span class="keyword">const</span> = 0;
00291     <span class="comment">// Functional part of addative model</span>
<a name="l00292"></a><a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#a2">00292</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#a2">normalise</a> (<a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <span class="comment">/*z_denorm*/</span>, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <span class="comment">/*z_from*/</span>) const
00293     <span class="comment">// Discontinous h. Normalise one observation (z_denorm) from another</span>
00294     {}  <span class="comment">//  Default normalistion, z_denorm unchanged</span>
00295     
<a name="l00296"></a><a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#o0">00296</a>     <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">Numerical_rcond</a> <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html#o0">rclimit</a>;
00297     <span class="comment">// Reciprocal condition number limit of linear components when factorised or inverted</span>
00298 };
00299 
<a name="l00300"></a><a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html">00300</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html">Uncorrelated_addative_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">Parametised_observe_model</a>
00301 <span class="comment">/* Observation model, uncorrelated addative observation noise</span>
00302 <span class="comment">    Z(k) = I * Zv(k) observe noise variance vector Zv</span>
00303 <span class="comment"> */</span>
00304 {
00305 <span class="keyword">public</span>:
<a name="l00306"></a><a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html#a0">00306</a>     <a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html#a0">Uncorrelated_addative_observe_model</a> (std::size_t z_size) :
00307         <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">Parametised_observe_model</a>(z_size), <a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html#o0">Zv</a>(z_size)
00308     {}
<a name="l00309"></a><a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html#o0">00309</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html#o0">Zv</a>;         <span class="comment">// Noise Variance</span>
00310 };
00311 
<a name="l00312"></a><a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html">00312</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html">Correlated_addative_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">Parametised_observe_model</a>
00313 <span class="comment">/* Observation model, correlated addative observation noise</span>
00314 <span class="comment">    Z(k) = observe noise covariance</span>
00315 <span class="comment"> */</span>
00316 {
00317 <span class="keyword">public</span>:
<a name="l00318"></a><a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html#a0">00318</a>     <a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html#a0">Correlated_addative_observe_model</a> (std::size_t z_size) :
00319         <a class="code" href="classBayesian__filter_1_1Parametised__observe__model.html">Parametised_observe_model</a>(z_size), <a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html#o0">Z</a>(z_size,z_size)
00320     {}
<a name="l00321"></a><a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html#o0">00321</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a> <a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html#o0">Z</a>;    <span class="comment">// Noise Covariance (not necessarly dense)</span>
00322 };
00323 
<a name="l00324"></a><a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">00324</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">Jacobian_observe_model</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Observe__model__base.html">Observe_model_base</a>
00325 <span class="comment">/* Linrz observation model Hx, h about state x (fixed size)</span>
00326 <span class="comment">    Hx(x(k|k-1) = Jacobian of h with respect to state x</span>
00327 <span class="comment">    Normalisation consistency Hx: Assume normalise will be from h(x(k|k-1)) so result is consistent with Hx</span>
00328 <span class="comment"> */</span>
00329 {
00330 <span class="keyword">public</span>:
<a name="l00331"></a><a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html#o0">00331</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a3">FM::Matrix</a> <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html#o0">Hx</a>;      <span class="comment">// Model</span>
00332 <span class="keyword">protected</span>: <span class="comment">// Jacobian model is not sufficient, it is used to build Linrz observe model's</span>
<a name="l00333"></a><a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html#b0">00333</a>     <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html#b0">Jacobian_observe_model</a> (std::size_t x_size, std::size_t z_size) :
00334         <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html#o0">Hx</a>(z_size, x_size)
00335     {}
00336 };
00337 
<a name="l00338"></a><a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">00338</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html">Correlated_addative_observe_model</a>, <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">Jacobian_observe_model</a>
00339 <span class="comment">/* Linrz observation model Hx, h with repespect to state x (fixed size)</span>
00340 <span class="comment">    correlated observation noise</span>
00341 <span class="comment">    zp(k) = h(x(k-1|k-1)</span>
00342 <span class="comment">    Hx(x(k|k-1) = Jacobian of f with respect to state x</span>
00343 <span class="comment">    Z(k) = observe noise covariance</span>
00344 <span class="comment"> */</span>
00345 {
00346 <span class="keyword">public</span>:
<a name="l00347"></a><a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html#a0">00347</a>     <a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html#a0">Linrz_correlated_observe_model</a> (std::size_t x_size, std::size_t z_size) :
00348         <a class="code" href="classBayesian__filter_1_1Correlated__addative__observe__model.html">Correlated_addative_observe_model</a>(z_size), <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">Jacobian_observe_model</a>(x_size, z_size)
00349     {}
00350 };
00351 
<a name="l00352"></a><a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">00352</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html">Uncorrelated_addative_observe_model</a>, <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">Jacobian_observe_model</a>
00353 <span class="comment">/* Linrz observation model Hx, h with repespect to state x (fixed size)</span>
00354 <span class="comment">    uncorrelated observation noise</span>
00355 <span class="comment">    zp(k) = h(x(k-1|k-1)</span>
00356 <span class="comment">    Hx(x(k|k-1) = Jacobian of f with respect to state x</span>
00357 <span class="comment">    Zv(k) = observe noise covariance</span>
00358 <span class="comment"> */</span>
00359 {
00360 <span class="keyword">public</span>:
<a name="l00361"></a><a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html#a0">00361</a>     <a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html#a0">Linrz_uncorrelated_observe_model</a> (std::size_t x_size, std::size_t z_size) :
00362         <a class="code" href="classBayesian__filter_1_1Uncorrelated__addative__observe__model.html">Uncorrelated_addative_observe_model</a>(z_size), <a class="code" href="classBayesian__filter_1_1Jacobian__observe__model.html">Jacobian_observe_model</a>(x_size, z_size)
00363     {}
00364 };
00365 
<a name="l00366"></a><a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html">00366</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html">Linear_correlated_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a>
00367 <span class="comment">/* Linear observation model, correlated observation noise</span>
00368 <span class="comment">    zp(k) = Hx(k) * x(k|k-1)</span>
00369 <span class="comment">    Enforces linear model invariant. Careful when deriving to to change this invariant!</span>
00370 <span class="comment"> */</span>
00371 {
00372 <span class="keyword">public</span>:
<a name="l00373"></a><a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html#a0">00373</a>     <a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html#a0">Linear_correlated_observe_model</a> (std::size_t x_size, std::size_t z_size) :
00374         <a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a>(x_size, z_size), hx(z_size)
00375     {}
<a name="l00376"></a><a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html#a1">00376</a>     <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Linear__correlated__observe__model.html#a1">h</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x)<span class="keyword"> const</span>
00377 <span class="keyword">    </span>{   <span class="comment">// Provide a linear implementation of functional h assumes model is already Linrz for Hx</span>
00378         hx.assign (FM::prod(Hx,x));
00379         <span class="keywordflow">return</span> hx;
00380     }
00381 <span class="keyword">private</span>:
00382     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> hx;
00383 };
00384 
<a name="l00385"></a><a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html">00385</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html">Linear_uncorrelated_observe_model</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a>
00386 <span class="comment">/* Linear observation model, uncorrelated observation noise</span>
00387 <span class="comment">    zp(k) = Hx(k) * x(k|k-1)</span>
00388 <span class="comment">    Enforces linear model invariant. Careful when deriving to to change this invariant!</span>
00389 <span class="comment"> */</span>
00390 {
00391 <span class="keyword">public</span>:
<a name="l00392"></a><a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html#a0">00392</a>     <a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html#a0">Linear_uncorrelated_observe_model</a> (std::size_t x_size, std::size_t z_size) :
00393         <a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a>(x_size, z_size), hx(z_size)
00394     {}
<a name="l00395"></a><a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html#a1">00395</a>     <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; <a class="code" href="classBayesian__filter_1_1Linear__uncorrelated__observe__model.html#a1">h</a>(<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x)<span class="keyword"> const</span>
00396 <span class="keyword">    </span>{   <span class="comment">// Provide a linear implementation of functional h assumes model is already Linrz for Hx</span>
00397         hx.assign (FM::prod(Hx,x));
00398         <span class="keywordflow">return</span> hx;
00399     }
00400 <span class="keyword">private</span>:
00401     <span class="keyword">mutable</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> hx;
00402 };
00403 
00404 
00405 <span class="comment">/*</span>
00406 <span class="comment"> * Bayesian Filter</span>
00407 <span class="comment"> *</span>
00408 <span class="comment"> * A Bayesian Filter uses Bayes rule to fuse the state probabilities</span>
00409 <span class="comment"> * of a prior and a likelhood function</span>
00410 <span class="comment"> */</span>
<a name="l00411"></a><a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">00411</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__base.html">Bayes_base</a>
00412 {
00413     <span class="comment">// Empty</span>
00414 };
00415 
00416 <span class="comment">/*</span>
00417 <span class="comment"> * Likelihood Filter - Abstract filtering property</span>
00418 <span class="comment"> * Represents only the Bayesian Likelihood of a state observation</span>
00419 <span class="comment"> */</span>
<a name="l00420"></a><a class="code" href="classBayesian__filter_1_1Likelihood__filter.html">00420</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Likelihood__filter.html">Likelihood_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00421 {
00422 <span class="keyword">public</span>:
00423     <span class="comment">/* Virtual functions for filter algorithm */</span>
00424 
00425     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Likelihood__filter.html#a0">observe</a> (<a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html">Likelihood_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z) = 0;
00426     <span class="comment">/* Observation state posterior using likelihood model h at z</span>
00427 <span class="comment">    */</span>
00428 };
00429 
00430 <span class="comment">/*</span>
00431 <span class="comment"> * Functional Filter - Abstract filtering property</span>
00432 <span class="comment"> * Represents only filter predict by a simple functional</span>
00433 <span class="comment"> * (non-stochastic) model</span>
00434 <span class="comment"> * </span>
00435 <span class="comment"> * A similar functional observe is not generally useful. The inverse of h is needed for observe!</span>
00436 <span class="comment"> */</span>
<a name="l00437"></a><a class="code" href="classBayesian__filter_1_1Functional__filter.html">00437</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Functional__filter.html">Functional_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00438 {
00439 <span class="keyword">public</span>:
00440     <span class="comment">/* Virtual functions for filter algorithm */</span>
00441 
00442     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Functional__filter.html#a0">predict</a> (<a class="code" href="classBayesian__filter_1_1Functional__predict__model.html">Functional_predict_model</a>&amp; f) = 0;
00443     <span class="comment">/* Predict state with functional no noise model</span>
00444 <span class="comment">        Requires x(k|k), X(k|k) or internal equivilent</span>
00445 <span class="comment">        Predicts x(k+1|k), X(k+1|k), using predict model</span>
00446 <span class="comment">    */</span>
00447 };
00448 
00449 <span class="comment">/*</span>
00450 <span class="comment"> * State Filter - Abstract filtering property</span>
00451 <span class="comment"> * Represents only filter state and an update on that state</span>
00452 <span class="comment"> */</span>
<a name="l00453"></a><a class="code" href="classBayesian__filter_1_1State__filter.html">00453</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1State__filter.html">State_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00454 {
00455 <span class="keyword">public</span>:
00456     <a class="code" href="classBayesian__filter_1_1State__filter.html#a0">State_filter</a> (std::size_t x_size);
00457     <span class="comment">/* Set constant sizes, state must not be empty (must be &gt;=1)</span>
00458 <span class="comment">        Exceptions:</span>
00459 <span class="comment">         bayes_filter_exception is x_size &lt; 1</span>
00460 <span class="comment">     */</span>
00461 
<a name="l00462"></a><a class="code" href="classBayesian__filter_1_1State__filter.html#o0">00462</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1State__filter.html#o0">x</a>;          <span class="comment">// expected state</span>
00463 
00464     <span class="comment">/* Virtual functions for filter algorithm */</span>
00465 
00466     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1State__filter.html#a1">update</a> () = 0;
00467     <span class="comment">/* Update filters state</span>
00468 <span class="comment">        Updates x(k|k)</span>
00469 <span class="comment">    */</span>
00470 };
00471 
00472 
00473 <span class="comment">/*</span>
00474 <span class="comment"> * Kalman State Filter - Abstract filtering property</span>
00475 <span class="comment"> * Linear filter representation for 1st (mean) and 2nd (covariance) moments of a distribution</span>
00476 <span class="comment"> *</span>
00477 <span class="comment"> * Probability distributions are represted by state vector (x) and a covariance matix.(X)</span>
00478 <span class="comment"> *</span>
00479 <span class="comment"> * State (x) sizes is assumed to remain constant.</span>
00480 <span class="comment"> * The state and state covariance are public so they can be directly manipulated.</span>
00481 <span class="comment"> *  init: Should be called if x or X are altered</span>
00482 <span class="comment"> *  update: Guarantees that any internal changes made filter are reflected in x,X.</span>
00483 <span class="comment"> *  This allows considerable flexibility so filter implemtations can use different numerical representations</span>
00484 <span class="comment"> *</span>
00485 <span class="comment"> * Derived filters supply definititions for the abstract functions and determine the algorithm used</span>
00486 <span class="comment"> * to implement the filter.</span>
00487 <span class="comment"> */</span>
00488 
<a name="l00489"></a><a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">00489</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">Kalman_state_filter</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1State__filter.html">State_filter</a>
00490 {
00491 <span class="keyword">public</span>:
<a name="l00492"></a><a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#o0">00492</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#o0">X</a>;    <span class="comment">// state covariance</span>
00493 
00494     <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#a0">Kalman_state_filter</a> (std::size_t x_size);
00495     <span class="comment">/* Initialise filter and set constant sizes</span>
00496 <span class="comment">     */</span>
00497 
00498     <span class="comment">/* Virtual functions for filter algorithm */</span>
00499 
00500     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#a1">init</a> () = 0;
00501     <span class="comment">/* Initialise from current state and state covariance</span>
00502 <span class="comment">        Requires x(k|k), X(k|k)</span>
00503 <span class="comment">    */</span>
00504     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#a2">init_kalman</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; x, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a>&amp; X);
00505     <span class="comment">/* Initialise from a state and state covariance</span>
00506 <span class="comment">        Parameters that reference the instance's x and X members are valid</span>
00507 <span class="comment">    */</span>
00508     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#a3">update</a> () = 0;
00509     <span class="comment">/* Update filters state and state covariance </span>
00510 <span class="comment">        Updates x(k|k), X(k|k)</span>
00511 <span class="comment">    */</span>
00512                         
00513     <span class="comment">// Minimum allowable reciprocal condition number for PD Matrix factorisations</span>
<a name="l00514"></a><a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#o1">00514</a>     <a class="code" href="classBayesian__filter_1_1Numerical__rcond.html">Numerical_rcond</a> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html#o1">rclimit</a>;
00515 };
00516 
00517 
00518 <span class="comment">/*</span>
00519 <span class="comment"> * Information State Filter - Abstract filtering property</span>
00520 <span class="comment"> * Linear filter information space representation for 1st (mean) and 2nd (covariance) moments of a distribution</span>
00521 <span class="comment"> *   Y = inv(X)   Information</span>
00522 <span class="comment"> *   y = Y*x      Information state</span>
00523 <span class="comment"> */</span>
00524 
<a name="l00525"></a><a class="code" href="classBayesian__filter_1_1Information__state__filter.html">00525</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Information__state__filter.html">Information_state_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00526 {
00527 <span class="keyword">public</span>:
00528     <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#a0">Information_state_filter</a> (std::size_t x_size);
<a name="l00529"></a><a class="code" href="classBayesian__filter_1_1Information__state__filter.html#o0">00529</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a> <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#o0">y</a>;              <span class="comment">// Information state</span>
<a name="l00530"></a><a class="code" href="classBayesian__filter_1_1Information__state__filter.html#o1">00530</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a> <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#o1">Y</a>;        <span class="comment">// Information</span>
00531 
00532     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#a1">init_yY</a> () =0;
00533     <span class="comment">/* Initialise from a information state and information</span>
00534 <span class="comment">        Requires y(k|k), Y(k|k)</span>
00535 <span class="comment">        Parameters that reference the instance's y and Y members are valid</span>
00536 <span class="comment">    */</span>
00537     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#a2">init_information</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; y, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a5">FM::SymMatrix</a>&amp; Y);
00538     <span class="comment">/* Initialise from a information state and information</span>
00539 <span class="comment">        Parameters that reference the instance's y and Y members are valid</span>
00540 <span class="comment">    */</span>
00541 
00542     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Information__state__filter.html#a3">update_yY</a> () =0;
00543     <span class="comment">/* Update filters information state and information</span>
00544 <span class="comment">        Updates y(k|k), Y(k|k)</span>
00545 <span class="comment">    */</span>
00546 };
00547 
00548 
00549 <span class="comment">/*</span>
00550 <span class="comment"> * Linearizable filter models - Abstract filtering property</span>
00551 <span class="comment"> *  Linrz == A linear, or gradient Linearized filter</span>
00552 <span class="comment"> *</span>
00553 <span class="comment"> * Predict uses a Linrz_predict_model that maintains a Jacobian matrix Fx and addative noise</span>
00554 <span class="comment"> * NOTE: Functional (non-stochastic) predict is NOT possible as predict requires Fx.</span>
00555 <span class="comment"> *</span>
00556 <span class="comment"> * Observe uses a Linrz_observe_model and a variable size observation (z)</span>
00557 <span class="comment"> * There are two variants for correlated and uncorrelated observation noise</span>
00558 <span class="comment"> * Derived filters supply the init,predict,observe,update functions and determine</span>
00559 <span class="comment"> * the algorithm used to implement the filter.</span>
00560 <span class="comment"> */</span>
00561 
<a name="l00562"></a><a class="code" href="classBayesian__filter_1_1Linrz__filter.html">00562</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linrz__filter.html">Linrz_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00563 { 
00564 <span class="keyword">public</span>:
00565     <span class="comment">/* Virtual functions for filter algorithm */</span>
00566 
00567     <span class="keyword">virtual</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Linrz__filter.html#a0">predict</a> (<a class="code" href="classBayesian__filter_1_1Linrz__predict__model.html">Linrz_predict_model</a>&amp; f) = 0;
00568     <span class="comment">/* Predict state using a Linrz model</span>
00569 <span class="comment">        Requires x(k|k), X(k|k) or internal equivilent</span>
00570 <span class="comment">        Returns: Reciprocal condition number of primary matrix used in predict computation (1. if none)</span>
00571 <span class="comment">    */</span>
00572 
00573     <span class="keyword">virtual</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Linrz__filter.html#a1">observe</a> (<a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z) = 0;
00574     <span class="keyword">virtual</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Linrz__filter.html#a1">observe</a> (<a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z) = 0;
00575     <span class="comment">/* Observation z(k) and with (Un)correlated observation noise model</span>
00576 <span class="comment">        Requires x(k|k), X(k|k) or internal equivilent</span>
00577 <span class="comment">        Returns: Reciprocal condition number of primary matrix used in observe computation (1. if none)</span>
00578 <span class="comment">    */</span>
00579 };
00580 
00581 
00582 <span class="comment">/*</span>
00583 <span class="comment"> * Linearizable Kalman Filter</span>
00584 <span class="comment"> *  Kalman state representation and linearizable models</span>
00585 <span class="comment"> *</span>
00586 <span class="comment"> * Common abstration for many linear filters</span>
00587 <span class="comment"> *  Has a virtual base to represent the common state</span>
00588 <span class="comment"> */</span>
<a name="l00589"></a><a class="code" href="classBayesian__filter_1_1Linrz__kalman__filter.html">00589</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Linrz__kalman__filter.html">Linrz_kalman_filter</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linrz__filter.html">Linrz_filter</a>, <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">Kalman_state_filter</a>
00590 {
00591 <span class="keyword">protected</span>:
<a name="l00592"></a><a class="code" href="classBayesian__filter_1_1Linrz__kalman__filter.html#b0">00592</a>     <a class="code" href="classBayesian__filter_1_1Linrz__kalman__filter.html#b0">Linrz_kalman_filter</a>() : <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">Kalman_state_filter</a>(0) <span class="comment">// define a default constructor</span>
00593     {}
00594 };
00595 
00596 
00597 <span class="comment">/*</span>
00598 <span class="comment"> * Extended Kalman Filter</span>
00599 <span class="comment"> *  Kalman state representation and linearizable models</span>
00600 <span class="comment"> *</span>
00601 <span class="comment"> * Observe is implemented using an innovation computed from the non-linear part of the</span>
00602 <span class="comment"> * obseve model and linear part of the Linrz_observe_model</span>
00603 <span class="comment"> *</span>
00604 <span class="comment"> * Common abstration for many linear filters</span>
00605 <span class="comment"> *  Has a virtual base to represent the common state</span>
00606 <span class="comment"> */</span>
<a name="l00607"></a><a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html">00607</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html">Extended_kalman_filter</a> : <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Linrz__kalman__filter.html">Linrz_kalman_filter</a>
00608 {
00609 <span class="keyword">protected</span>:
<a name="l00610"></a><a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#b0">00610</a>     <a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#b0">Extended_kalman_filter</a>() : <a class="code" href="classBayesian__filter_1_1Kalman__state__filter.html">Kalman_state_filter</a>(0) <span class="comment">// define a default constructor</span>
00611     {}
00612 <span class="keyword">public</span>:
00613     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#a0">observe</a> (<a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z);
00614     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#a0">observe</a> (<a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z);
00615     <span class="comment">/* Observation z(k) and with (Un)correlated observation noise model</span>
00616 <span class="comment">        Requires x(k|k), X(k|k) or internal equivilent</span>
00617 <span class="comment">        Returns: Reciprocal condition number of primary matrix used in observe computation (1. if none)</span>
00618 <span class="comment">        Default implementation simple computes innovation for observe_innovation</span>
00619 <span class="comment">    */</span>
00620 
00621     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#a2">observe_innovation</a> (<a class="code" href="classBayesian__filter_1_1Linrz__uncorrelated__observe__model.html">Linrz_uncorrelated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; s) = 0;
00622     <span class="keyword">virtual</span> Float <a class="code" href="classBayesian__filter_1_1Extended__kalman__filter.html#a2">observe_innovation</a> (<a class="code" href="classBayesian__filter_1_1Linrz__correlated__observe__model.html">Linrz_correlated_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; s) = 0;
00623     <span class="comment">/* Observation innovation s(k) and with (Un)correlated observation noise model</span>
00624 <span class="comment">        Requires x(k|k), X(k|k) or internal equivilent</span>
00625 <span class="comment">        Returns: Reciprocal condition number of primary matrix used in observe computation (1. if none)</span>
00626 <span class="comment">    */</span>
00627 };
00628 
00629 
00630 <span class="comment">/*</span>
00631 <span class="comment"> * Sample State Filter - Abstract filtering property</span>
00632 <span class="comment"> *</span>
00633 <span class="comment"> * Probability distributions are represted by a finite sampling</span>
00634 <span class="comment"> *</span>
00635 <span class="comment"> * State (x_size) size and its sampling (s_size) are assumed to remain constant.</span>
00636 <span class="comment"> * The state sampling public so they can be directly manipulated.</span>
00637 <span class="comment"> *  init: Should be used if they to be altered</span>
00638 <span class="comment"> *  update: Guarantees that any internal changes made filter are reflected in sampling S.</span>
00639 <span class="comment"> */</span>
00640 
<a name="l00641"></a><a class="code" href="classBayesian__filter_1_1Sample__state__filter.html">00641</a> <span class="keyword">class </span><a class="code" href="classBayesian__filter_1_1Sample__state__filter.html">Sample_state_filter</a> : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classBayesian__filter_1_1Bayes__filter__base.html">Bayes_filter_base</a>
00642 {
00643 <span class="keyword">public</span>:
<a name="l00644"></a><a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#o0">00644</a>     <a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a> <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#o0">S</a>;        <span class="comment">// state sampleing (x_size,s_size)</span>
00645 
00646     <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a0">Sample_state_filter</a> (std::size_t x_size, std::size_t s_size);
00647     <span class="comment">/* Initialise filter and set constant sizes for</span>
00648 <span class="comment">        x_size of the state vector</span>
00649 <span class="comment">        s_size sample size</span>
00650 <span class="comment">        Exceptions:</span>
00651 <span class="comment">         bayes_filter_exception is s_size &lt; 1</span>
00652 <span class="comment">    */</span>
00653     <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a1">~Sample_state_filter</a>() = 0; <span class="comment">// ISSUE Provide unambigues distructor incase S is not distructable</span>
00654 
00655     <span class="comment">/* Virtual functions for filter algorithm */</span>
00656 
00657     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a2">init_S</a> () = 0;
00658     <span class="comment">/* Initialise from current sampleing</span>
00659 <span class="comment">    */</span>
00660 
00661     <span class="keywordtype">void</span> <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a3">init_sample</a> (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a4">FM::ColMatrix</a>&amp; initS);
00662     <span class="comment">/* Initialise from a sampling</span>
00663 <span class="comment">     */</span>
00664 
00665     <span class="keyword">virtual</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a0">Float</a> <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a4">update_resample</a> () = 0;
00666     <span class="comment">/* Resampling update</span>
00667 <span class="comment">        Returns lcond, Smallest normalised likelihood weight, represents conditioning of resampling solution</span>
00668 <span class="comment">                lcond == 1. if no resampling performed</span>
00669 <span class="comment">                This should by multipled by the number of samples to get the Likelihood function conditioning</span>
00670 <span class="comment">     */</span>
00671 
00672     std::size_t <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html#a5">unique_samples</a> () const;
00673     <span class="comment">/* Count number of unique (unequal value) samples in S</span>
00674 <span class="comment">        Implementation requires std::sort on sample column references</span>
00675 <span class="comment">    */</span>
00676 };
00677 
00678 
00679 <span class="comment">/*</span>
00680 <span class="comment"> * Sample Filter: Bayes filter using</span>
00681 <span class="comment"> *</span>
00682 <span class="comment"> * Probability distributions are represted by a finite sampling</span>
00683 <span class="comment"> *</span>
00684 <span class="comment"> * The filter is operated by performing a</span>
00685 <span class="comment"> *  predict, observe</span>
00686 <span class="comment"> * cycle derived from the bayes_filter. observe Likelihoods are merged into a single combined weight.</span>
00687 <span class="comment"> *   update: MUST be used to complete a explict resampling of the particles using merged weights</span>
00688 <span class="comment"> *</span>
00689 <span class="comment"> * Derived filters supply definititions for the abstract functions and determine the algorithm used</span>
00690 <span class="comment"> * to implement the filter.</span>
00691 <span class="comment"> */</span>
00692 
<a name="l00693"></a><a class="code" href="classBayesian__filter_1_1Sample__filter.html">00693</a> class <a class="code" href="classBayesian__filter_1_1Sample__filter.html">Sample_filter</a> : public <a class="code" href="classBayesian__filter_1_1Likelihood__filter.html">Likelihood_filter</a>, public <a class="code" href="classBayesian__filter_1_1Functional__filter.html">Functional_filter</a>, virtual public <a class="code" href="classBayesian__filter_1_1Sample__state__filter.html">Sample_state_filter</a>
00694 {
00695 <span class="keyword">public</span>:
00696     <a class="code" href="classBayesian__filter_1_1Sample__filter.html">Sample_filter</a> (std::size_t x_size, std::size_t s_size);
00697     <span class="comment">/* Initialise filter and set constant sizes for</span>
00698 <span class="comment">        x_size of the state vector</span>
00699 <span class="comment">        s_size sample size</span>
00700 <span class="comment">        Exceptions:</span>
00701 <span class="comment">         bayes_filter_exception is s_size &lt; 1</span>
00702 <span class="comment">    */</span>
00703 
00704     <span class="comment">/* Virtual functions for filter algorithm */</span>
00705 
00706     <span class="keyword">virtual</span> <span class="keywordtype">void</span> predict (<a class="code" href="classBayesian__filter_1_1Functional__predict__model.html">Functional_predict_model</a>&amp; f);
00707     <span class="comment">/* Predict state posterior with functional no noise model</span>
00708 <span class="comment">    */</span>
00709 
00710     <span class="keyword">virtual</span> <span class="keywordtype">void</span> predict (<a class="code" href="classBayesian__filter_1_1Sampled__predict__model.html">Sampled_predict_model</a>&amp; f) = 0;
00711     <span class="comment">/* Predict state posterior with sampled noise model</span>
00712 <span class="comment">    */</span>
00713 
00714     <span class="keyword">virtual</span> <span class="keywordtype">void</span> observe (<a class="code" href="classBayesian__filter_1_1Likelihood__observe__model.html">Likelihood_observe_model</a>&amp; h, <span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; z) = 0;
00715     <span class="comment">/* Observation state posterior using likelihood model h at z</span>
00716 <span class="comment">    */</span>
00717 
00718     <span class="keyword">virtual</span> <span class="keywordtype">void</span> observe_likelihood (<span class="keyword">const</span> <a class="code" href="namespaceBayesian__filter__matrix.html#a1">FM::Vec</a>&amp; lw) = 0;
00719     <span class="comment">/* Observation fusion directly from likelihood weights</span>
00720 <span class="comment">        lw may be smaller then the state sampling. Weights for additional particles are assumed to be 1</span>
00721 <span class="comment">    */</span>
00722 };
00723 
00724 
00725 }<span class="comment">//namespace</span>
00726 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 19:23:17 2005 for Bayes++ Bayesian Filtering Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
